syntax = "proto3";

package regen.data.v1alpha2;

import "google/protobuf/timestamp.proto";
import "cosmos/base/query/v1beta1/pagination.proto";
import "regen/data/v1alpha2/types.proto";

option go_package = "github.com/regen-network/regen-ledger/x/data";

// Query is the regen.data.v1alpha1 Query service
service Query {
  // ByHash queries data based on its ContentHash.
  rpc ByHash (QueryByHashRequest) returns (QueryByHashResponse);

  // BySigner queries data based on signers.
  rpc BySigner (QueryBySignerRequest) returns (QueryBySignerResponse);

  rpc ConvertToCompactDataset (ConvertToCompactDatasetRequest) returns (ConvertToCompactDatasetResponse);
}

// QueryByContentHashRequest is the Query/ByContentHash request type.
message QueryByHashRequest {
  // hash is the hash-based identifier for the anchored content.
  ContentHash hash = 1;
}

// QueryByContentHashResponse is the Query/ByContentHash response type.
message QueryByHashResponse {
  // entry is the ContentEntry
  ContentEntry entry = 1;
}

// QueryBySignerRequest is the Query/BySigner request type.
message QueryBySignerRequest {
  // signer is the address of the signer to query by.
  string signer = 1;

  // pagination is the PageRequest to use for pagination.
  cosmos.base.query.v1beta1.PageRequest pagination = 2;
}

// QueryBySignerResponse is the Query/BySigner response type.
message QueryBySignerResponse {
  // entries is the ContentEntry's signed by the queried signer
  repeated ContentEntry entries = 1;

  // pagination is the pagination PageResponse.
  cosmos.base.query.v1beta1.PageResponse pagination = 3;
}

// ContentEntry describes data referenced and possibly stored on chain
message ContentEntry {
  // hash is the content hash
  ContentHash hash = 1;

  // iri is the content IRI
  string iri = 2;

  // timestamp is the anchor Timestamp
  google.protobuf.Timestamp timestamp = 3;

  // signers are the signers, if any
  repeated SignerEntry signers = 4;

  // content is the actual content if stored on-chain
  Content content = 5;
}

message ConvertToCompactDatasetRequest {
  bytes content = 1;
  string content_type = 2;

  // content_hash provides an optional ContentHash.Graph to be verified when converting
  // the RDF data to the compact dataset format. If content_hash is provided and the node
  // does not produce the expected hash, an error will be returned which includes the hash
  // the node calculated using the same hash method as the client. This method is intended
  // to be used to confirm that a client's hash implementation matches a node's.
  // Generally, however, clients which conform to specifications should trust their own hashes
  // and not those returned by nodes as that would expose clients to attacks by malicious nodes.
  ContentHash.Graph content_hash = 3;
}

message ConvertToCompactDatasetResponse {
  // compact_dataset is regen.data.internal.v1alpha2.CompactDataset under the hood,
  // but because this type is not generally needed for clients and should only
  // be manipulated by "advanced" users, it is left out of the API and most users
  // should just treat this as opaque bytes to be passed to Msg/StoreGraphData.
  bytes compact_dataset = 1;
}
