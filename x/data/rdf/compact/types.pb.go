// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/data/internal/v1alpha2/types.proto

package compact

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type WellknownDatatype int32

const (
	WellknownDatatype_DATATYPE_UNSPECIFIED   WellknownDatatype = 0
	WellknownDatatype_DATATYPE_BOOL_FALSE    WellknownDatatype = 1
	WellknownDatatype_DATATYPE_BOOL_TRUE     WellknownDatatype = 2
	WellknownDatatype_DATATYPE_DECIMAL       WellknownDatatype = 3
	WellknownDatatype_DATATYPE_INTEGER       WellknownDatatype = 4
	WellknownDatatype_DATATYPE_STRING        WellknownDatatype = 5
	WellknownDatatype_DATATYPE_ANY_URI       WellknownDatatype = 6
	WellknownDatatype_DATATYPE_DATE          WellknownDatatype = 7
	WellknownDatatype_DATATYPE_TIME          WellknownDatatype = 8
	WellknownDatatype_DATATYPE_DATE_TIME     WellknownDatatype = 9
	WellknownDatatype_DATATYPE_BASE64_STRING WellknownDatatype = 10
	WellknownDatatype_DATATYPE_WKT_LITERAL   WellknownDatatype = 11
)

var WellknownDatatype_name = map[int32]string{
	0:  "DATATYPE_UNSPECIFIED",
	1:  "DATATYPE_BOOL_FALSE",
	2:  "DATATYPE_BOOL_TRUE",
	3:  "DATATYPE_DECIMAL",
	4:  "DATATYPE_INTEGER",
	5:  "DATATYPE_STRING",
	6:  "DATATYPE_ANY_URI",
	7:  "DATATYPE_DATE",
	8:  "DATATYPE_TIME",
	9:  "DATATYPE_DATE_TIME",
	10: "DATATYPE_BASE64_STRING",
	11: "DATATYPE_WKT_LITERAL",
}

var WellknownDatatype_value = map[string]int32{
	"DATATYPE_UNSPECIFIED":   0,
	"DATATYPE_BOOL_FALSE":    1,
	"DATATYPE_BOOL_TRUE":     2,
	"DATATYPE_DECIMAL":       3,
	"DATATYPE_INTEGER":       4,
	"DATATYPE_STRING":        5,
	"DATATYPE_ANY_URI":       6,
	"DATATYPE_DATE":          7,
	"DATATYPE_TIME":          8,
	"DATATYPE_DATE_TIME":     9,
	"DATATYPE_BASE64_STRING": 10,
	"DATATYPE_WKT_LITERAL":   11,
}

func (x WellknownDatatype) String() string {
	return proto.EnumName(WellknownDatatype_name, int32(x))
}

func (WellknownDatatype) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d03575205ba2e5ad, []int{0}
}

type CompactDataset struct {
	Nodes   []*Node  `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	NewIris []string `protobuf:"bytes,2,rep,name=new_iris,json=newIris,proto3" json:"new_iris,omitempty"`
}

func (m *CompactDataset) Reset()         { *m = CompactDataset{} }
func (m *CompactDataset) String() string { return proto.CompactTextString(m) }
func (*CompactDataset) ProtoMessage()    {}
func (*CompactDataset) Descriptor() ([]byte, []int) {
	return fileDescriptor_d03575205ba2e5ad, []int{0}
}
func (m *CompactDataset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactDataset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactDataset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactDataset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactDataset.Merge(m, src)
}
func (m *CompactDataset) XXX_Size() int {
	return m.Size()
}
func (m *CompactDataset) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactDataset.DiscardUnknown(m)
}

var xxx_messageInfo_CompactDataset proto.InternalMessageInfo

func (m *CompactDataset) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *CompactDataset) GetNewIris() []string {
	if m != nil {
		return m.NewIris
	}
	return nil
}

type Node struct {
	// Types that are valid to be assigned to Subject:
	//	*Node_InternalId
	//	*Node_LocalRef
	Subject    isNode_Subject `protobuf_oneof:"subject"`
	Properties []*Properties  `protobuf:"bytes,3,rep,name=properties,proto3" json:"properties,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_d03575205ba2e5ad, []int{1}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

type isNode_Subject interface {
	isNode_Subject()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Node_InternalId struct {
	InternalId []byte `protobuf:"bytes,1,opt,name=internal_id,json=internalId,proto3,oneof" json:"internal_id,omitempty"`
}
type Node_LocalRef struct {
	LocalRef int32 `protobuf:"zigzag32,2,opt,name=local_ref,json=localRef,proto3,oneof" json:"local_ref,omitempty"`
}

func (*Node_InternalId) isNode_Subject() {}
func (*Node_LocalRef) isNode_Subject()   {}

func (m *Node) GetSubject() isNode_Subject {
	if m != nil {
		return m.Subject
	}
	return nil
}

func (m *Node) GetInternalId() []byte {
	if x, ok := m.GetSubject().(*Node_InternalId); ok {
		return x.InternalId
	}
	return nil
}

func (m *Node) GetLocalRef() int32 {
	if x, ok := m.GetSubject().(*Node_LocalRef); ok {
		return x.LocalRef
	}
	return 0
}

func (m *Node) GetProperties() []*Properties {
	if m != nil {
		return m.Properties
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Node) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Node_InternalId)(nil),
		(*Node_LocalRef)(nil),
	}
}

type Properties struct {
	// Types that are valid to be assigned to Predicate:
	//	*Properties_InternalId
	//	*Properties_LocalRef
	Predicate isProperties_Predicate `protobuf_oneof:"predicate"`
	Objects   []*ObjectGraph         `protobuf:"bytes,3,rep,name=objects,proto3" json:"objects,omitempty"`
}

func (m *Properties) Reset()         { *m = Properties{} }
func (m *Properties) String() string { return proto.CompactTextString(m) }
func (*Properties) ProtoMessage()    {}
func (*Properties) Descriptor() ([]byte, []int) {
	return fileDescriptor_d03575205ba2e5ad, []int{2}
}
func (m *Properties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Properties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Properties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Properties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Properties.Merge(m, src)
}
func (m *Properties) XXX_Size() int {
	return m.Size()
}
func (m *Properties) XXX_DiscardUnknown() {
	xxx_messageInfo_Properties.DiscardUnknown(m)
}

var xxx_messageInfo_Properties proto.InternalMessageInfo

type isProperties_Predicate interface {
	isProperties_Predicate()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Properties_InternalId struct {
	InternalId []byte `protobuf:"bytes,1,opt,name=internal_id,json=internalId,proto3,oneof" json:"internal_id,omitempty"`
}
type Properties_LocalRef struct {
	LocalRef int32 `protobuf:"zigzag32,2,opt,name=local_ref,json=localRef,proto3,oneof" json:"local_ref,omitempty"`
}

func (*Properties_InternalId) isProperties_Predicate() {}
func (*Properties_LocalRef) isProperties_Predicate()   {}

func (m *Properties) GetPredicate() isProperties_Predicate {
	if m != nil {
		return m.Predicate
	}
	return nil
}

func (m *Properties) GetInternalId() []byte {
	if x, ok := m.GetPredicate().(*Properties_InternalId); ok {
		return x.InternalId
	}
	return nil
}

func (m *Properties) GetLocalRef() int32 {
	if x, ok := m.GetPredicate().(*Properties_LocalRef); ok {
		return x.LocalRef
	}
	return 0
}

func (m *Properties) GetObjects() []*ObjectGraph {
	if m != nil {
		return m.Objects
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Properties) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Properties_InternalId)(nil),
		(*Properties_LocalRef)(nil),
	}
}

type ObjectGraph struct {
	// Types that are valid to be assigned to Sum:
	//	*ObjectGraph_ObjectInternalId
	//	*ObjectGraph_ObjectLocalRef
	//	*ObjectGraph_WellKnownDatatype
	//	*ObjectGraph_DataTypeInternalId
	//	*ObjectGraph_DataTypeLocalRef
	//	*ObjectGraph_LangTag
	Sum    isObjectGraph_Sum `protobuf_oneof:"sum"`
	Graphs []*GraphID        `protobuf:"bytes,7,rep,name=graphs,proto3" json:"graphs,omitempty"`
	// Types that are valid to be assigned to LiteralValue:
	//	*ObjectGraph_StrValue
	LiteralValue isObjectGraph_LiteralValue `protobuf_oneof:"literal_value"`
}

func (m *ObjectGraph) Reset()         { *m = ObjectGraph{} }
func (m *ObjectGraph) String() string { return proto.CompactTextString(m) }
func (*ObjectGraph) ProtoMessage()    {}
func (*ObjectGraph) Descriptor() ([]byte, []int) {
	return fileDescriptor_d03575205ba2e5ad, []int{3}
}
func (m *ObjectGraph) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectGraph) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectGraph.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectGraph) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectGraph.Merge(m, src)
}
func (m *ObjectGraph) XXX_Size() int {
	return m.Size()
}
func (m *ObjectGraph) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectGraph.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectGraph proto.InternalMessageInfo

type isObjectGraph_Sum interface {
	isObjectGraph_Sum()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isObjectGraph_LiteralValue interface {
	isObjectGraph_LiteralValue()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ObjectGraph_ObjectInternalId struct {
	ObjectInternalId []byte `protobuf:"bytes,1,opt,name=object_internal_id,json=objectInternalId,proto3,oneof" json:"object_internal_id,omitempty"`
}
type ObjectGraph_ObjectLocalRef struct {
	ObjectLocalRef int32 `protobuf:"zigzag32,2,opt,name=object_local_ref,json=objectLocalRef,proto3,oneof" json:"object_local_ref,omitempty"`
}
type ObjectGraph_WellKnownDatatype struct {
	WellKnownDatatype WellknownDatatype `protobuf:"varint,3,opt,name=well_known_datatype,json=wellKnownDatatype,proto3,enum=regen.data.internal.v1alpha2.WellknownDatatype,oneof" json:"well_known_datatype,omitempty"`
}
type ObjectGraph_DataTypeInternalId struct {
	DataTypeInternalId []byte `protobuf:"bytes,4,opt,name=data_type_internal_id,json=dataTypeInternalId,proto3,oneof" json:"data_type_internal_id,omitempty"`
}
type ObjectGraph_DataTypeLocalRef struct {
	DataTypeLocalRef int32 `protobuf:"zigzag32,5,opt,name=data_type_local_ref,json=dataTypeLocalRef,proto3,oneof" json:"data_type_local_ref,omitempty"`
}
type ObjectGraph_LangTag struct {
	LangTag string `protobuf:"bytes,6,opt,name=lang_tag,json=langTag,proto3,oneof" json:"lang_tag,omitempty"`
}
type ObjectGraph_StrValue struct {
	StrValue string `protobuf:"bytes,8,opt,name=str_value,json=strValue,proto3,oneof" json:"str_value,omitempty"`
}

func (*ObjectGraph_ObjectInternalId) isObjectGraph_Sum()   {}
func (*ObjectGraph_ObjectLocalRef) isObjectGraph_Sum()     {}
func (*ObjectGraph_WellKnownDatatype) isObjectGraph_Sum()  {}
func (*ObjectGraph_DataTypeInternalId) isObjectGraph_Sum() {}
func (*ObjectGraph_DataTypeLocalRef) isObjectGraph_Sum()   {}
func (*ObjectGraph_LangTag) isObjectGraph_Sum()            {}
func (*ObjectGraph_StrValue) isObjectGraph_LiteralValue()  {}

func (m *ObjectGraph) GetSum() isObjectGraph_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}
func (m *ObjectGraph) GetLiteralValue() isObjectGraph_LiteralValue {
	if m != nil {
		return m.LiteralValue
	}
	return nil
}

func (m *ObjectGraph) GetObjectInternalId() []byte {
	if x, ok := m.GetSum().(*ObjectGraph_ObjectInternalId); ok {
		return x.ObjectInternalId
	}
	return nil
}

func (m *ObjectGraph) GetObjectLocalRef() int32 {
	if x, ok := m.GetSum().(*ObjectGraph_ObjectLocalRef); ok {
		return x.ObjectLocalRef
	}
	return 0
}

func (m *ObjectGraph) GetWellKnownDatatype() WellknownDatatype {
	if x, ok := m.GetSum().(*ObjectGraph_WellKnownDatatype); ok {
		return x.WellKnownDatatype
	}
	return WellknownDatatype_DATATYPE_UNSPECIFIED
}

func (m *ObjectGraph) GetDataTypeInternalId() []byte {
	if x, ok := m.GetSum().(*ObjectGraph_DataTypeInternalId); ok {
		return x.DataTypeInternalId
	}
	return nil
}

func (m *ObjectGraph) GetDataTypeLocalRef() int32 {
	if x, ok := m.GetSum().(*ObjectGraph_DataTypeLocalRef); ok {
		return x.DataTypeLocalRef
	}
	return 0
}

func (m *ObjectGraph) GetLangTag() string {
	if x, ok := m.GetSum().(*ObjectGraph_LangTag); ok {
		return x.LangTag
	}
	return ""
}

func (m *ObjectGraph) GetGraphs() []*GraphID {
	if m != nil {
		return m.Graphs
	}
	return nil
}

func (m *ObjectGraph) GetStrValue() string {
	if x, ok := m.GetLiteralValue().(*ObjectGraph_StrValue); ok {
		return x.StrValue
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ObjectGraph) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ObjectGraph_ObjectInternalId)(nil),
		(*ObjectGraph_ObjectLocalRef)(nil),
		(*ObjectGraph_WellKnownDatatype)(nil),
		(*ObjectGraph_DataTypeInternalId)(nil),
		(*ObjectGraph_DataTypeLocalRef)(nil),
		(*ObjectGraph_LangTag)(nil),
		(*ObjectGraph_StrValue)(nil),
	}
}

type GraphID struct {
	// Types that are valid to be assigned to Graph:
	//	*GraphID_InternalId
	//	*GraphID_LocalRef
	Graph isGraphID_Graph `protobuf_oneof:"graph"`
}

func (m *GraphID) Reset()         { *m = GraphID{} }
func (m *GraphID) String() string { return proto.CompactTextString(m) }
func (*GraphID) ProtoMessage()    {}
func (*GraphID) Descriptor() ([]byte, []int) {
	return fileDescriptor_d03575205ba2e5ad, []int{4}
}
func (m *GraphID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GraphID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GraphID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphID.Merge(m, src)
}
func (m *GraphID) XXX_Size() int {
	return m.Size()
}
func (m *GraphID) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphID.DiscardUnknown(m)
}

var xxx_messageInfo_GraphID proto.InternalMessageInfo

type isGraphID_Graph interface {
	isGraphID_Graph()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GraphID_InternalId struct {
	InternalId []byte `protobuf:"bytes,1,opt,name=internal_id,json=internalId,proto3,oneof" json:"internal_id,omitempty"`
}
type GraphID_LocalRef struct {
	LocalRef int32 `protobuf:"zigzag32,2,opt,name=local_ref,json=localRef,proto3,oneof" json:"local_ref,omitempty"`
}

func (*GraphID_InternalId) isGraphID_Graph() {}
func (*GraphID_LocalRef) isGraphID_Graph()   {}

func (m *GraphID) GetGraph() isGraphID_Graph {
	if m != nil {
		return m.Graph
	}
	return nil
}

func (m *GraphID) GetInternalId() []byte {
	if x, ok := m.GetGraph().(*GraphID_InternalId); ok {
		return x.InternalId
	}
	return nil
}

func (m *GraphID) GetLocalRef() int32 {
	if x, ok := m.GetGraph().(*GraphID_LocalRef); ok {
		return x.LocalRef
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GraphID) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GraphID_InternalId)(nil),
		(*GraphID_LocalRef)(nil),
	}
}

func init() {
	proto.RegisterEnum("regen.data.internal.v1alpha2.WellknownDatatype", WellknownDatatype_name, WellknownDatatype_value)
	proto.RegisterType((*CompactDataset)(nil), "regen.data.internal.v1alpha2.CompactDataset")
	proto.RegisterType((*Node)(nil), "regen.data.internal.v1alpha2.Node")
	proto.RegisterType((*Properties)(nil), "regen.data.internal.v1alpha2.Properties")
	proto.RegisterType((*ObjectGraph)(nil), "regen.data.internal.v1alpha2.ObjectGraph")
	proto.RegisterType((*GraphID)(nil), "regen.data.internal.v1alpha2.GraphID")
}

func init() {
	proto.RegisterFile("regen/data/internal/v1alpha2/types.proto", fileDescriptor_d03575205ba2e5ad)
}

var fileDescriptor_d03575205ba2e5ad = []byte{
	// 713 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xcd, 0x4e, 0xc3, 0x46,
	0x18, 0xb4, 0x13, 0x12, 0x27, 0x5f, 0x0a, 0x38, 0x1b, 0x4a, 0xdd, 0xbf, 0x28, 0x8d, 0x54, 0xc9,
	0x45, 0xaa, 0xad, 0x42, 0x55, 0x71, 0xe9, 0xc1, 0x49, 0x0c, 0xb1, 0x08, 0x01, 0x6d, 0x4c, 0x11,
	0xbd, 0x58, 0x4b, 0xbc, 0x04, 0x17, 0x63, 0x5b, 0xeb, 0x0d, 0x29, 0x6f, 0xd1, 0x17, 0xa8, 0xd4,
	0x6b, 0x1f, 0xa4, 0x52, 0x8f, 0x1c, 0x7b, 0xac, 0xe0, 0x45, 0x2a, 0xdb, 0x71, 0x7e, 0x44, 0x95,
	0x4b, 0x7b, 0xdc, 0xf9, 0x66, 0xc6, 0x33, 0xeb, 0x4f, 0x0b, 0x2a, 0xa3, 0x13, 0x1a, 0xe8, 0x2e,
	0xe1, 0x44, 0xf7, 0x02, 0x4e, 0x59, 0x40, 0x7c, 0xfd, 0xe9, 0x1b, 0xe2, 0x47, 0xf7, 0xe4, 0x50,
	0xe7, 0xcf, 0x11, 0x8d, 0xb5, 0x88, 0x85, 0x3c, 0x44, 0x9f, 0xa5, 0x4c, 0x2d, 0x61, 0x6a, 0x39,
	0x53, 0xcb, 0x99, 0x6d, 0x0a, 0x3b, 0xdd, 0xf0, 0x31, 0x22, 0x63, 0xde, 0x23, 0x9c, 0xc4, 0x94,
	0xa3, 0x63, 0x28, 0x05, 0xa1, 0x4b, 0x63, 0x45, 0x6c, 0x15, 0xd5, 0xda, 0x61, 0x5b, 0xdb, 0xa4,
	0xd7, 0x86, 0xa1, 0x4b, 0x71, 0x26, 0x40, 0x1f, 0x43, 0x25, 0xa0, 0x33, 0xc7, 0x63, 0x5e, 0xac,
	0x14, 0x5a, 0x45, 0xb5, 0x8a, 0xa5, 0x80, 0xce, 0x2c, 0xe6, 0xc5, 0xed, 0x5f, 0x45, 0xd8, 0x4a,
	0xa8, 0xe8, 0x0b, 0xa8, 0xe5, 0x26, 0x8e, 0xe7, 0x2a, 0x62, 0x4b, 0x54, 0x3f, 0xe8, 0x0b, 0x18,
	0x72, 0xd0, 0x72, 0xd1, 0xe7, 0x50, 0xf5, 0xc3, 0x31, 0xf1, 0x1d, 0x46, 0xef, 0x94, 0x42, 0x4b,
	0x54, 0xeb, 0x7d, 0x01, 0x57, 0x52, 0x08, 0xd3, 0x3b, 0xd4, 0x07, 0x88, 0x58, 0x18, 0x51, 0xc6,
	0x3d, 0x1a, 0x2b, 0xc5, 0x34, 0xa4, 0xba, 0x39, 0xe4, 0xe5, 0x82, 0x8f, 0x57, 0xb4, 0x9d, 0x2a,
	0x48, 0xf1, 0xf4, 0xf6, 0x27, 0x3a, 0xe6, 0xed, 0xdf, 0x44, 0x80, 0x25, 0xeb, 0x7f, 0x48, 0xd9,
	0x05, 0x29, 0x4c, 0xad, 0xf3, 0x88, 0x5f, 0x6d, 0x8e, 0x78, 0x91, 0x92, 0x4f, 0x19, 0x89, 0xee,
	0x71, 0xae, 0xec, 0xd4, 0xa0, 0x1a, 0x31, 0xea, 0x7a, 0x63, 0xc2, 0x69, 0xfb, 0x8f, 0x22, 0xd4,
	0x56, 0x58, 0x48, 0x03, 0x94, 0xf1, 0x9c, 0x7f, 0x8b, 0x2a, 0x67, 0x33, 0x6b, 0x19, 0xf8, 0x00,
	0xe6, 0x98, 0xf3, 0x3e, 0xf7, 0x4e, 0x36, 0x19, 0xe4, 0xe9, 0x09, 0x34, 0x66, 0xd4, 0xf7, 0x9d,
	0x87, 0x20, 0x9c, 0x05, 0x4e, 0x12, 0x39, 0xd9, 0x28, 0xa5, 0xd8, 0x12, 0xd5, 0x9d, 0x43, 0x7d,
	0x73, 0x93, 0x6b, 0xea, 0xfb, 0xa9, 0xae, 0x37, 0x97, 0xf5, 0x05, 0x5c, 0x4f, 0xdc, 0xce, 0x56,
	0x41, 0x74, 0x04, 0x1f, 0x26, 0x06, 0x4e, 0x72, 0x58, 0x6b, 0xb0, 0x35, 0x6f, 0x80, 0x92, 0xb1,
	0xfd, 0x1c, 0xd1, 0x95, 0x0e, 0x3a, 0x34, 0x96, 0xa2, 0x65, 0x8d, 0xd2, 0xbc, 0x86, 0x9c, 0x4b,
	0x16, 0x45, 0x3e, 0x85, 0x8a, 0x4f, 0x82, 0x89, 0xc3, 0xc9, 0x44, 0x29, 0xb7, 0x44, 0xb5, 0xda,
	0x17, 0xb0, 0x94, 0x20, 0x36, 0x99, 0xa0, 0xef, 0xa1, 0x3c, 0x49, 0xae, 0x32, 0x56, 0xa4, 0xf4,
	0x17, 0x7d, 0xb9, 0xb9, 0x58, 0x7a, 0xed, 0x56, 0x0f, 0xcf, 0x45, 0xc9, 0x06, 0xc4, 0x9c, 0x39,
	0x4f, 0xc4, 0x9f, 0x52, 0xa5, 0x92, 0x9a, 0x8b, 0xb8, 0x12, 0x73, 0xf6, 0x43, 0x82, 0x74, 0x4a,
	0x50, 0x8c, 0xa7, 0x8f, 0x9d, 0x5d, 0xd8, 0xf6, 0x3d, 0x4e, 0x19, 0xf1, 0x33, 0x66, 0xdb, 0x06,
	0x69, 0xee, 0xf4, 0xdf, 0xd7, 0xac, 0x23, 0x41, 0x29, 0x4d, 0x73, 0xf0, 0x7b, 0x01, 0xea, 0xef,
	0x6e, 0x1e, 0x29, 0xb0, 0xd7, 0x33, 0x6c, 0xc3, 0xbe, 0xb9, 0x34, 0x9d, 0xab, 0xe1, 0xe8, 0xd2,
	0xec, 0x5a, 0x27, 0x96, 0xd9, 0x93, 0x05, 0xf4, 0x11, 0x34, 0x16, 0x93, 0xce, 0xc5, 0xc5, 0xc0,
	0x39, 0x31, 0x06, 0x23, 0x53, 0x16, 0xd1, 0x3e, 0xa0, 0xf5, 0x81, 0x8d, 0xaf, 0x4c, 0xb9, 0x80,
	0xf6, 0x40, 0x5e, 0xe0, 0x3d, 0xb3, 0x6b, 0x9d, 0x1b, 0x03, 0xb9, 0xb8, 0x86, 0x5a, 0x43, 0xdb,
	0x3c, 0x35, 0xb1, 0xbc, 0x85, 0x1a, 0xb0, 0xbb, 0x40, 0x47, 0x36, 0xb6, 0x86, 0xa7, 0x72, 0x69,
	0x8d, 0x6a, 0x0c, 0x6f, 0x9c, 0x2b, 0x6c, 0xc9, 0x65, 0x54, 0x87, 0xed, 0xa5, 0xad, 0x61, 0x9b,
	0xb2, 0xb4, 0x06, 0xd9, 0xd6, 0xb9, 0x29, 0x57, 0xd6, 0x42, 0x25, 0xac, 0x0c, 0xaf, 0xa2, 0x4f,
	0x60, 0x7f, 0x19, 0xd6, 0x18, 0x99, 0xdf, 0x7d, 0x9b, 0x7f, 0x0f, 0xd6, 0xba, 0x5f, 0x9f, 0xd9,
	0xce, 0xc0, 0xb2, 0x4d, 0x6c, 0x0c, 0xe4, 0x5a, 0x07, 0xff, 0xf9, 0xda, 0x14, 0x5f, 0x5e, 0x9b,
	0xe2, 0xdf, 0xaf, 0x4d, 0xf1, 0x97, 0xb7, 0xa6, 0xf0, 0xf2, 0xd6, 0x14, 0xfe, 0x7a, 0x6b, 0x0a,
	0x3f, 0x1e, 0x4f, 0x3c, 0x7e, 0x3f, 0xbd, 0xd5, 0xc6, 0xe1, 0xa3, 0x9e, 0xee, 0xc2, 0xd7, 0x01,
	0xe5, 0xb3, 0x90, 0x3d, 0xcc, 0x4f, 0x3e, 0x75, 0x27, 0x94, 0xe9, 0x3f, 0x67, 0xef, 0x2e, 0x73,
	0xef, 0xf4, 0x71, 0xf6, 0x78, 0xde, 0x96, 0xd3, 0xc7, 0xf6, 0xe8, 0x9f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x28, 0xa2, 0x4d, 0xab, 0x98, 0x05, 0x00, 0x00,
}

func (m *CompactDataset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactDataset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewIris) > 0 {
		for iNdEx := len(m.NewIris) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NewIris[iNdEx])
			copy(dAtA[i:], m.NewIris[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.NewIris[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Properties) > 0 {
		for iNdEx := len(m.Properties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Properties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Subject != nil {
		{
			size := m.Subject.Size()
			i -= size
			if _, err := m.Subject.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InternalId != nil {
		i -= len(m.InternalId)
		copy(dAtA[i:], m.InternalId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InternalId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Node_LocalRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_LocalRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64((uint32(m.LocalRef)<<1)^uint32((m.LocalRef>>31))))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Properties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Properties) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Properties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for iNdEx := len(m.Objects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Objects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Predicate != nil {
		{
			size := m.Predicate.Size()
			i -= size
			if _, err := m.Predicate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Properties_InternalId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Properties_InternalId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InternalId != nil {
		i -= len(m.InternalId)
		copy(dAtA[i:], m.InternalId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InternalId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Properties_LocalRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Properties_LocalRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64((uint32(m.LocalRef)<<1)^uint32((m.LocalRef>>31))))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *ObjectGraph) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectGraph) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectGraph) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LiteralValue != nil {
		{
			size := m.LiteralValue.Size()
			i -= size
			if _, err := m.LiteralValue.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Graphs) > 0 {
		for iNdEx := len(m.Graphs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Graphs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Sum != nil {
		{
			size := m.Sum.Size()
			i -= size
			if _, err := m.Sum.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ObjectGraph_ObjectInternalId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectGraph_ObjectInternalId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ObjectInternalId != nil {
		i -= len(m.ObjectInternalId)
		copy(dAtA[i:], m.ObjectInternalId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ObjectInternalId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ObjectGraph_ObjectLocalRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectGraph_ObjectLocalRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64((uint32(m.ObjectLocalRef)<<1)^uint32((m.ObjectLocalRef>>31))))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *ObjectGraph_WellKnownDatatype) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectGraph_WellKnownDatatype) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.WellKnownDatatype))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *ObjectGraph_DataTypeInternalId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectGraph_DataTypeInternalId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DataTypeInternalId != nil {
		i -= len(m.DataTypeInternalId)
		copy(dAtA[i:], m.DataTypeInternalId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DataTypeInternalId)))
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ObjectGraph_DataTypeLocalRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectGraph_DataTypeLocalRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64((uint32(m.DataTypeLocalRef)<<1)^uint32((m.DataTypeLocalRef>>31))))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *ObjectGraph_LangTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectGraph_LangTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.LangTag)
	copy(dAtA[i:], m.LangTag)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.LangTag)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *ObjectGraph_StrValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectGraph_StrValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.StrValue)
	copy(dAtA[i:], m.StrValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.StrValue)))
	i--
	dAtA[i] = 0x42
	return len(dAtA) - i, nil
}
func (m *GraphID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Graph != nil {
		{
			size := m.Graph.Size()
			i -= size
			if _, err := m.Graph.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GraphID_InternalId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphID_InternalId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InternalId != nil {
		i -= len(m.InternalId)
		copy(dAtA[i:], m.InternalId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InternalId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *GraphID_LocalRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphID_LocalRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64((uint32(m.LocalRef)<<1)^uint32((m.LocalRef>>31))))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CompactDataset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NewIris) > 0 {
		for _, s := range m.NewIris {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subject != nil {
		n += m.Subject.Size()
	}
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Node_InternalId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternalId != nil {
		l = len(m.InternalId)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Node_LocalRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sozTypes(uint64(m.LocalRef))
	return n
}
func (m *Properties) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Predicate != nil {
		n += m.Predicate.Size()
	}
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Properties_InternalId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternalId != nil {
		l = len(m.InternalId)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Properties_LocalRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sozTypes(uint64(m.LocalRef))
	return n
}
func (m *ObjectGraph) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != nil {
		n += m.Sum.Size()
	}
	if len(m.Graphs) > 0 {
		for _, e := range m.Graphs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LiteralValue != nil {
		n += m.LiteralValue.Size()
	}
	return n
}

func (m *ObjectGraph_ObjectInternalId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectInternalId != nil {
		l = len(m.ObjectInternalId)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ObjectGraph_ObjectLocalRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sozTypes(uint64(m.ObjectLocalRef))
	return n
}
func (m *ObjectGraph_WellKnownDatatype) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.WellKnownDatatype))
	return n
}
func (m *ObjectGraph_DataTypeInternalId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataTypeInternalId != nil {
		l = len(m.DataTypeInternalId)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ObjectGraph_DataTypeLocalRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sozTypes(uint64(m.DataTypeLocalRef))
	return n
}
func (m *ObjectGraph_LangTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LangTag)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ObjectGraph_StrValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StrValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GraphID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Graph != nil {
		n += m.Graph.Size()
	}
	return n
}

func (m *GraphID_InternalId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternalId != nil {
		l = len(m.InternalId)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GraphID_LocalRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sozTypes(uint64(m.LocalRef))
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CompactDataset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactDataset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactDataset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewIris", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewIris = append(m.NewIris, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Subject = &Node_InternalId{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalRef", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Subject = &Node_LocalRef{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, &Properties{})
			if err := m.Properties[len(m.Properties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Properties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Properties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Properties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Predicate = &Properties_InternalId{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalRef", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Predicate = &Properties_LocalRef{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &ObjectGraph{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectGraph) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectGraph: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectGraph: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectInternalId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Sum = &ObjectGraph_ObjectInternalId{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectLocalRef", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Sum = &ObjectGraph_ObjectLocalRef{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WellKnownDatatype", wireType)
			}
			var v WellknownDatatype
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= WellknownDatatype(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sum = &ObjectGraph_WellKnownDatatype{v}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTypeInternalId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Sum = &ObjectGraph_DataTypeInternalId{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTypeLocalRef", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Sum = &ObjectGraph_DataTypeLocalRef{v}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sum = &ObjectGraph_LangTag{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Graphs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Graphs = append(m.Graphs, &GraphID{})
			if err := m.Graphs[len(m.Graphs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiteralValue = &ObjectGraph_StrValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Graph = &GraphID_InternalId{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalRef", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Graph = &GraphID_LocalRef{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
