// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/data/v1alpha2/types.proto

package data

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type IDType int32

const (
	// ID_TYPE_RAW_UNSPECIFIED specifies "raw" data which does not specify a deterministic, canonical encoding.
	// Users of these hashes MUST maintain a copy of the hashed data which is preserved bit by bit.
	// All other encodings in IDType specify a deterministic, canonical encoding allowing implementations to
	// choose from a variety of alternative formats for transport and encoding while maintaining the guarantee
	// that the canonical hash will not change. The media type for "raw" data used with ID_TYPE_RAW_UNSPECIFIED
	// is defined by the MediaType enum.
	IDType_ID_TYPE_RAW_UNSPECIFIED IDType = 0
	// ID_TYPE_GRAPH specifies graph data that conforms to the RDF data model.
	// The canonicalization algorithm used for an RDF graph is specified by GraphCanonicalizationAlgorithm.
	IDType_ID_TYPE_GRAPH IDType = 1
	// ID_TYPE_GEOGRAPHY specifies geographic data conforming to this canonicalization algorithm:
	//
	// We define the canonical lexical representation of a geography as its  [WKT](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry) serialization with the following additional restrictions:
	//
	// ## **General Rules**
	//
	// - only the WGS 84 reference coordinate system is supported and all coordinates should be assumed to be in WGS 84
	// - only 2D and 3D coordinates are supported, coordinates with linear referencing systems or an “M” component are unsupported
	//
	// ## **`POLYGON` Rules**
	//
	// - exterior linear rings must be defined in counterclockwise direction
	// - interior linear rings must be defined in clockwise direction
	// - where there is more than one ring, the first MUST be the exterior ring and other rings MUST be linear rings - this means that the area of a polygon MUST be continuous and unbroken. To represent multiple non-contiguous shapes, a `MULTIPOLYGON` should be used instead. Ex: in the case where inside of a hole in a polygon, there is an island that we want to include. Because the island is disjoint, this shape must be represented as a `MULTIPOLYGON` instead of a `POLYGON` with a hole and an island in the hole
	// - the first and last point in a linear ring must be identical
	// - *canonical coordinate ordering rule*: the first (and last) point in a linear ring must be the point with the minimum X value in the ring. In the event where there is more than one point in a ring with the minimum X value, the first point must be the one with the minimum Y value. For 3D geometries, if there is is more than one point with the minimum X and Y values, the one with the minimum Z value should be the first.
	// - if there is more than one interior linear ring, those rings should be ordered using the above *canonical coordinate ordering rule*, i.e. the ring with the minimum X coordinate comes first, etc.
	//
	// ## `**MULTIPOLYGON` Rules**
	//
	// - each polygon should conform to the above `POLYGON` rules
	// - if there is more than one polygon, those polygons should be ordered using the above *canonical coordinate ordering rule*, i.e. the polygon with the minimum X coordinate comes first, etc.
	IDType_ID_TYPE_GEOGRAPHY IDType = 2
)

var IDType_name = map[int32]string{
	0: "ID_TYPE_RAW_UNSPECIFIED",
	1: "ID_TYPE_GRAPH",
	2: "ID_TYPE_GEOGRAPHY",
}

var IDType_value = map[string]int32{
	"ID_TYPE_RAW_UNSPECIFIED": 0,
	"ID_TYPE_GRAPH":           1,
	"ID_TYPE_GEOGRAPHY":       2,
}

func (x IDType) String() string {
	return proto.EnumName(IDType_name, int32(x))
}

func (IDType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{0}
}

// MediaType defines MIME media types to be used with ID_TYPE_RAW_UNSPECIFIED.
type MediaType int32

const (
	MediaType_MEDIA_TYPE_UNSPECIFIED MediaType = 0
	// basic formats
	MediaType_MEDIA_TYPE_TEXT_PLAIN   MediaType = 1
	MediaType_MEDIA_TYPE_JSON         MediaType = 2
	MediaType_MEDIA_TYPE_CSV          MediaType = 3
	MediaType_MEDIA_TYPE_XML          MediaType = 4
	MediaType_MEDIA_TYPE_PROTOBUF_ANY MediaType = 5
	MediaType_MEDIA_TYPE_PDF          MediaType = 6
	// images
	MediaType_MEDIA_TYPE_TIFF MediaType = 16
	MediaType_MEDIA_TYPE_JPG  MediaType = 17
	MediaType_MEDIA_TYPE_PNG  MediaType = 18
	MediaType_MEDIA_TYPE_SVG  MediaType = 19
	MediaType_MEDIA_TYPE_WEBP MediaType = 20
	MediaType_MEDIA_TYPE_AVIF MediaType = 21
	MediaType_MEDIA_TYPE_GIF  MediaType = 22
	MediaType_MEDIA_TYPE_APNG MediaType = 23
	// audio-visual media containers
	MediaType_MEDIA_TYPE_MPEG MediaType = 32
	MediaType_MEDIA_TYPE_MP4  MediaType = 33
	MediaType_MEDIA_TYPE_WEBM MediaType = 34
	MediaType_MEDIA_TYPE_OGG  MediaType = 35
)

var MediaType_name = map[int32]string{
	0:  "MEDIA_TYPE_UNSPECIFIED",
	1:  "MEDIA_TYPE_TEXT_PLAIN",
	2:  "MEDIA_TYPE_JSON",
	3:  "MEDIA_TYPE_CSV",
	4:  "MEDIA_TYPE_XML",
	5:  "MEDIA_TYPE_PROTOBUF_ANY",
	6:  "MEDIA_TYPE_PDF",
	16: "MEDIA_TYPE_TIFF",
	17: "MEDIA_TYPE_JPG",
	18: "MEDIA_TYPE_PNG",
	19: "MEDIA_TYPE_SVG",
	20: "MEDIA_TYPE_WEBP",
	21: "MEDIA_TYPE_AVIF",
	22: "MEDIA_TYPE_GIF",
	23: "MEDIA_TYPE_APNG",
	32: "MEDIA_TYPE_MPEG",
	33: "MEDIA_TYPE_MP4",
	34: "MEDIA_TYPE_WEBM",
	35: "MEDIA_TYPE_OGG",
}

var MediaType_value = map[string]int32{
	"MEDIA_TYPE_UNSPECIFIED":  0,
	"MEDIA_TYPE_TEXT_PLAIN":   1,
	"MEDIA_TYPE_JSON":         2,
	"MEDIA_TYPE_CSV":          3,
	"MEDIA_TYPE_XML":          4,
	"MEDIA_TYPE_PROTOBUF_ANY": 5,
	"MEDIA_TYPE_PDF":          6,
	"MEDIA_TYPE_TIFF":         16,
	"MEDIA_TYPE_JPG":          17,
	"MEDIA_TYPE_PNG":          18,
	"MEDIA_TYPE_SVG":          19,
	"MEDIA_TYPE_WEBP":         20,
	"MEDIA_TYPE_AVIF":         21,
	"MEDIA_TYPE_GIF":          22,
	"MEDIA_TYPE_APNG":         23,
	"MEDIA_TYPE_MPEG":         32,
	"MEDIA_TYPE_MP4":          33,
	"MEDIA_TYPE_WEBM":         34,
	"MEDIA_TYPE_OGG":          35,
}

func (x MediaType) String() string {
	return proto.EnumName(MediaType_name, int32(x))
}

func (MediaType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{1}
}

type GraphCanonicalizationAlgorithm int32

const (
	GraphCanonicalizationAlgorithm_GRAPH_CANONICALIZATION_ALGORITHM_URDNA2015_UNSPECIFIED GraphCanonicalizationAlgorithm = 0
)

var GraphCanonicalizationAlgorithm_name = map[int32]string{
	0: "GRAPH_CANONICALIZATION_ALGORITHM_URDNA2015_UNSPECIFIED",
}

var GraphCanonicalizationAlgorithm_value = map[string]int32{
	"GRAPH_CANONICALIZATION_ALGORITHM_URDNA2015_UNSPECIFIED": 0,
}

func (x GraphCanonicalizationAlgorithm) String() string {
	return proto.EnumName(GraphCanonicalizationAlgorithm_name, int32(x))
}

func (GraphCanonicalizationAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{2}
}

type DigestAlgorithm int32

const (
	DigestAlgorithm_DIGEST_ALGORITHM_SHA256_UNSPECIFIED DigestAlgorithm = 0
	DigestAlgorithm_DIGEST_ALGORITHM_BLAKE2B_256        DigestAlgorithm = 1
)

var DigestAlgorithm_name = map[int32]string{
	0: "DIGEST_ALGORITHM_SHA256_UNSPECIFIED",
	1: "DIGEST_ALGORITHM_BLAKE2B_256",
}

var DigestAlgorithm_value = map[string]int32{
	"DIGEST_ALGORITHM_SHA256_UNSPECIFIED": 0,
	"DIGEST_ALGORITHM_BLAKE2B_256":        1,
}

func (x DigestAlgorithm) String() string {
	return proto.EnumName(DigestAlgorithm_name, int32(x))
}

func (DigestAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{3}
}

// ID specifies a hash based content identifier for a piece of data
type ID struct {
	// type specifies the IDType for the ID
	Type IDType `protobuf:"varint,1,opt,name=type,proto3,enum=regen.data.v1alpha2.IDType" json:"type,omitempty"`
	// hash represents the hash of the data based on the specified digest_algorithm and canonicalization algorithm
	// for types other than ID_TYPE_RAW_UNSPECIFIED.
	Hash []byte `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	// digest_algorithm represents the hash digest algorithm.
	DigestAlgorithm DigestAlgorithm `protobuf:"varint,3,opt,name=digest_algorithm,json=digestAlgorithm,proto3,enum=regen.data.v1alpha2.DigestAlgorithm" json:"digest_algorithm,omitempty"`
	// media_type represents the MediaType for data with ID_TYPE_RAW_UNSPECIFIED. It should be left unset
	// if type is not ID_TYPE_RAW_UNSPECIFIED.
	MediaType MediaType `protobuf:"varint,4,opt,name=media_type,json=mediaType,proto3,enum=regen.data.v1alpha2.MediaType" json:"media_type,omitempty"`
	// graph_canonicalization_algorithm represents the RDF graph canonicalization algorithm. It should
	// be left unset if type is not ID_TYPE_GRAPH.
	GraphCanonicalizationAlgorithm GraphCanonicalizationAlgorithm `protobuf:"varint,5,opt,name=graph_canonicalization_algorithm,json=graphCanonicalizationAlgorithm,proto3,enum=regen.data.v1alpha2.GraphCanonicalizationAlgorithm" json:"graph_canonicalization_algorithm,omitempty"`
}

func (m *ID) Reset()         { *m = ID{} }
func (m *ID) String() string { return proto.CompactTextString(m) }
func (*ID) ProtoMessage()    {}
func (*ID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{0}
}
func (m *ID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ID.Merge(m, src)
}
func (m *ID) XXX_Size() int {
	return m.Size()
}
func (m *ID) XXX_DiscardUnknown() {
	xxx_messageInfo_ID.DiscardUnknown(m)
}

var xxx_messageInfo_ID proto.InternalMessageInfo

func (m *ID) GetType() IDType {
	if m != nil {
		return m.Type
	}
	return IDType_ID_TYPE_RAW_UNSPECIFIED
}

func (m *ID) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *ID) GetDigestAlgorithm() DigestAlgorithm {
	if m != nil {
		return m.DigestAlgorithm
	}
	return DigestAlgorithm_DIGEST_ALGORITHM_SHA256_UNSPECIFIED
}

func (m *ID) GetMediaType() MediaType {
	if m != nil {
		return m.MediaType
	}
	return MediaType_MEDIA_TYPE_UNSPECIFIED
}

func (m *ID) GetGraphCanonicalizationAlgorithm() GraphCanonicalizationAlgorithm {
	if m != nil {
		return m.GraphCanonicalizationAlgorithm
	}
	return GraphCanonicalizationAlgorithm_GRAPH_CANONICALIZATION_ALGORITHM_URDNA2015_UNSPECIFIED
}

func init() {
	proto.RegisterEnum("regen.data.v1alpha2.IDType", IDType_name, IDType_value)
	proto.RegisterEnum("regen.data.v1alpha2.MediaType", MediaType_name, MediaType_value)
	proto.RegisterEnum("regen.data.v1alpha2.GraphCanonicalizationAlgorithm", GraphCanonicalizationAlgorithm_name, GraphCanonicalizationAlgorithm_value)
	proto.RegisterEnum("regen.data.v1alpha2.DigestAlgorithm", DigestAlgorithm_name, DigestAlgorithm_value)
	proto.RegisterType((*ID)(nil), "regen.data.v1alpha2.ID")
}

func init() { proto.RegisterFile("regen/data/v1alpha2/types.proto", fileDescriptor_e68eefb44eeab1df) }

var fileDescriptor_e68eefb44eeab1df = []byte{
	// 603 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x94, 0xcb, 0x4e, 0xdb, 0x4c,
	0x1c, 0xc5, 0xe3, 0x10, 0x90, 0x18, 0x7d, 0x1f, 0x0c, 0x43, 0xb9, 0xb4, 0x54, 0x6e, 0x0a, 0x95,
	0x8a, 0xa2, 0xd6, 0x2e, 0xa6, 0xb0, 0xa8, 0xd4, 0xc5, 0x24, 0xbe, 0x30, 0x34, 0xbe, 0xc8, 0x36,
	0x57, 0x21, 0x8d, 0x0c, 0xb1, 0x6c, 0xab, 0x49, 0x1c, 0x19, 0xf7, 0x42, 0xa5, 0xbe, 0x43, 0x9f,
	0xa2, 0xcf, 0xd2, 0x25, 0x4b, 0x96, 0x15, 0xbc, 0x48, 0xe5, 0xa1, 0xa1, 0xce, 0x10, 0xb1, 0x1b,
	0x9f, 0xff, 0xef, 0x9c, 0xf9, 0x8f, 0xe7, 0x02, 0x9e, 0x65, 0x61, 0x14, 0xf6, 0xe5, 0x4e, 0x90,
	0x07, 0xf2, 0xe7, 0x8d, 0xa0, 0x3b, 0x88, 0x03, 0x45, 0xce, 0x2f, 0x06, 0xe1, 0xb9, 0x34, 0xc8,
	0xd2, 0x3c, 0x45, 0xf3, 0x0c, 0x90, 0x0a, 0x40, 0x1a, 0x02, 0xab, 0x57, 0x55, 0x50, 0x25, 0x2a,
	0x92, 0x41, 0xad, 0x40, 0x97, 0x85, 0xba, 0xb0, 0x3e, 0xa3, 0xac, 0x48, 0x63, 0x50, 0x89, 0xa8,
	0xfe, 0xc5, 0x20, 0x74, 0x19, 0x88, 0x10, 0xa8, 0xc5, 0xc1, 0x79, 0xbc, 0x5c, 0xad, 0x0b, 0xeb,
	0xff, 0xb9, 0x6c, 0x8c, 0x6c, 0x00, 0x3b, 0x49, 0x14, 0x9e, 0xe7, 0x34, 0xe8, 0x46, 0x69, 0x96,
	0xe4, 0x71, 0x6f, 0x79, 0x82, 0x05, 0xbe, 0x18, 0x1b, 0xa8, 0x32, 0x18, 0x0f, 0x59, 0x77, 0xb6,
	0x33, 0x2a, 0xa0, 0xf7, 0x00, 0xf4, 0xc2, 0x4e, 0x12, 0x50, 0xd6, 0x5b, 0x8d, 0x45, 0x89, 0x63,
	0xa3, 0xcc, 0x02, 0x63, 0xed, 0x4d, 0xf7, 0x86, 0x43, 0xf4, 0x1d, 0xd4, 0xa3, 0x2c, 0x18, 0xc4,
	0xf4, 0x2c, 0xe8, 0xa7, 0xfd, 0xe4, 0x2c, 0xe8, 0x26, 0xdf, 0x82, 0x3c, 0x49, 0xfb, 0xa5, 0xfe,
	0x26, 0x59, 0xe8, 0xe6, 0xd8, 0x50, 0xa3, 0x30, 0xb7, 0x38, 0xef, 0xbf, 0x76, 0xc5, 0xe8, 0xc1,
	0x7a, 0xc3, 0x06, 0x53, 0xb7, 0xbf, 0x0c, 0xad, 0x80, 0x25, 0xa2, 0x52, 0xff, 0xc8, 0xd1, 0xa8,
	0x8b, 0x0f, 0xe8, 0x9e, 0xe5, 0x39, 0x5a, 0x8b, 0xe8, 0x44, 0x53, 0x61, 0x05, 0xcd, 0x81, 0xff,
	0x87, 0x45, 0xc3, 0xc5, 0xce, 0x0e, 0x14, 0xd0, 0x02, 0x98, 0xbb, 0x93, 0x34, 0x9b, 0xa9, 0x47,
	0xb0, 0xda, 0xf8, 0x39, 0x01, 0xa6, 0xef, 0x16, 0x8a, 0x9e, 0x80, 0x45, 0x53, 0x53, 0x09, 0xbe,
	0xe5, 0x46, 0x33, 0x1f, 0x83, 0x85, 0x52, 0xcd, 0xd7, 0x0e, 0x7d, 0xea, 0xb4, 0x31, 0xb1, 0xa0,
	0x80, 0xe6, 0xc1, 0x6c, 0xa9, 0xb4, 0xeb, 0xd9, 0x16, 0xac, 0x22, 0x04, 0x66, 0x4a, 0x62, 0xcb,
	0xdb, 0x87, 0x13, 0x9c, 0x76, 0x68, 0xb6, 0x61, 0xad, 0x58, 0x48, 0x49, 0x73, 0x5c, 0xdb, 0xb7,
	0x9b, 0x7b, 0x3a, 0xc5, 0xd6, 0x11, 0x9c, 0xe4, 0x0c, 0x8e, 0xaa, 0xc3, 0x29, 0x6e, 0x36, 0x9f,
	0xe8, 0x3a, 0x84, 0x1c, 0xb8, 0xeb, 0x18, 0x70, 0x8e, 0x37, 0x5b, 0x06, 0x44, 0x9c, 0xe6, 0xed,
	0x1b, 0x70, 0x9e, 0x0b, 0x3c, 0xd0, 0x9a, 0x0e, 0x7c, 0xc4, 0x89, 0x78, 0x9f, 0xe8, 0x70, 0x81,
	0x73, 0x1b, 0x44, 0x87, 0x8b, 0x3c, 0x58, 0x4c, 0xb3, 0xc4, 0x89, 0xa6, 0xa3, 0x19, 0xb0, 0xce,
	0xb9, 0x4d, 0xe7, 0x2d, 0x7c, 0x7e, 0x7f, 0x6e, 0x13, 0xae, 0x72, 0xa0, 0x6d, 0x18, 0x70, 0xad,
	0x71, 0x02, 0xc4, 0x87, 0xcf, 0x0e, 0x7a, 0x07, 0xb6, 0xd9, 0xb6, 0xd2, 0x16, 0xb6, 0x6c, 0x8b,
	0xb4, 0x70, 0x9b, 0x1c, 0x63, 0x9f, 0xd8, 0x16, 0xc5, 0x6d, 0xc3, 0x76, 0x89, 0xbf, 0x63, 0xd2,
	0x3d, 0x57, 0xb5, 0xb0, 0xf2, 0x66, 0x63, 0x6b, 0x74, 0x73, 0x1b, 0x27, 0x60, 0x96, 0xbb, 0x39,
	0xe8, 0x25, 0x58, 0x53, 0x89, 0xa1, 0x79, 0x7e, 0xc9, 0xee, 0xed, 0x60, 0x65, 0x6b, 0x9b, 0x3b,
	0x18, 0x75, 0xf0, 0xf4, 0x1e, 0xd8, 0x6c, 0xe3, 0x0f, 0x9a, 0xd2, 0xa4, 0xca, 0xd6, 0x36, 0x14,
	0x9a, 0xfa, 0xaf, 0x6b, 0x51, 0xb8, 0xbc, 0x16, 0x85, 0xdf, 0xd7, 0xa2, 0xf0, 0xe3, 0x46, 0xac,
	0x5c, 0xde, 0x88, 0x95, 0xab, 0x1b, 0xb1, 0x72, 0xfc, 0x2a, 0x4a, 0xf2, 0xf8, 0xd3, 0xa9, 0x74,
	0x96, 0xf6, 0x64, 0x76, 0x5d, 0x5e, 0xf7, 0xc3, 0xfc, 0x4b, 0x9a, 0x7d, 0xfc, 0xfb, 0xd5, 0x0d,
	0x3b, 0x51, 0x98, 0xc9, 0x5f, 0xd9, 0x13, 0x74, 0x3a, 0xc5, 0x1e, 0x9d, 0xcd, 0x3f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x85, 0x65, 0x21, 0x5e, 0x97, 0x04, 0x00, 0x00,
}

func (m *ID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GraphCanonicalizationAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GraphCanonicalizationAlgorithm))
		i--
		dAtA[i] = 0x28
	}
	if m.MediaType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MediaType))
		i--
		dAtA[i] = 0x20
	}
	if m.DigestAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DigestAlgorithm))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DigestAlgorithm != 0 {
		n += 1 + sovTypes(uint64(m.DigestAlgorithm))
	}
	if m.MediaType != 0 {
		n += 1 + sovTypes(uint64(m.MediaType))
	}
	if m.GraphCanonicalizationAlgorithm != 0 {
		n += 1 + sovTypes(uint64(m.GraphCanonicalizationAlgorithm))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= IDType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigestAlgorithm", wireType)
			}
			m.DigestAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigestAlgorithm |= DigestAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			m.MediaType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaType |= MediaType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphCanonicalizationAlgorithm", wireType)
			}
			m.GraphCanonicalizationAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GraphCanonicalizationAlgorithm |= GraphCanonicalizationAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
