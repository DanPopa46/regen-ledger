// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/data/v1alpha2/types.proto

package data

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MediaType defines MIME media types to be used with a ContentHash.Raw hash.
type MediaType int32

const (
	// MEDIA_TYPE_UNSPECIFIED can be used for raw binary data
	MediaType_MEDIA_TYPE_UNSPECIFIED MediaType = 0
	// plain text
	MediaType_MEDIA_TYPE_TEXT_PLAIN MediaType = 1
	// JSON
	MediaType_MEDIA_TYPE_JSON MediaType = 2
	// CSV
	MediaType_MEDIA_TYPE_CSV MediaType = 3
	// XML
	MediaType_MEDIA_TYPE_XML MediaType = 4
	// PDF
	MediaType_MEDIA_TYPE_PDF MediaType = 5
	// TIIF
	MediaType_MEDIA_TYPE_TIFF MediaType = 16
	// JPG
	MediaType_MEDIA_TYPE_JPG MediaType = 17
	// PNG
	MediaType_MEDIA_TYPE_PNG MediaType = 18
	// SVG
	MediaType_MEDIA_TYPE_SVG MediaType = 19
	// WEBP
	MediaType_MEDIA_TYPE_WEBP MediaType = 20
	// AVIF
	MediaType_MEDIA_TYPE_AVIF MediaType = 21
	// GIF
	MediaType_MEDIA_TYPE_GIF MediaType = 22
	// APNG
	MediaType_MEDIA_TYPE_APNG MediaType = 23
	// MPEG
	MediaType_MEDIA_TYPE_MPEG MediaType = 32
	// MP4
	MediaType_MEDIA_TYPE_MP4 MediaType = 33
	// WEBM
	MediaType_MEDIA_TYPE_WEBM MediaType = 34
	// OGG
	MediaType_MEDIA_TYPE_OGG MediaType = 35
)

var MediaType_name = map[int32]string{
	0:  "MEDIA_TYPE_UNSPECIFIED",
	1:  "MEDIA_TYPE_TEXT_PLAIN",
	2:  "MEDIA_TYPE_JSON",
	3:  "MEDIA_TYPE_CSV",
	4:  "MEDIA_TYPE_XML",
	5:  "MEDIA_TYPE_PDF",
	16: "MEDIA_TYPE_TIFF",
	17: "MEDIA_TYPE_JPG",
	18: "MEDIA_TYPE_PNG",
	19: "MEDIA_TYPE_SVG",
	20: "MEDIA_TYPE_WEBP",
	21: "MEDIA_TYPE_AVIF",
	22: "MEDIA_TYPE_GIF",
	23: "MEDIA_TYPE_APNG",
	32: "MEDIA_TYPE_MPEG",
	33: "MEDIA_TYPE_MP4",
	34: "MEDIA_TYPE_WEBM",
	35: "MEDIA_TYPE_OGG",
}

var MediaType_value = map[string]int32{
	"MEDIA_TYPE_UNSPECIFIED": 0,
	"MEDIA_TYPE_TEXT_PLAIN":  1,
	"MEDIA_TYPE_JSON":        2,
	"MEDIA_TYPE_CSV":         3,
	"MEDIA_TYPE_XML":         4,
	"MEDIA_TYPE_PDF":         5,
	"MEDIA_TYPE_TIFF":        16,
	"MEDIA_TYPE_JPG":         17,
	"MEDIA_TYPE_PNG":         18,
	"MEDIA_TYPE_SVG":         19,
	"MEDIA_TYPE_WEBP":        20,
	"MEDIA_TYPE_AVIF":        21,
	"MEDIA_TYPE_GIF":         22,
	"MEDIA_TYPE_APNG":        23,
	"MEDIA_TYPE_MPEG":        32,
	"MEDIA_TYPE_MP4":         33,
	"MEDIA_TYPE_WEBM":        34,
	"MEDIA_TYPE_OGG":         35,
}

func (x MediaType) String() string {
	return proto.EnumName(MediaType_name, int32(x))
}

func (MediaType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{0}
}

// GraphCanonicalizationAlgorithm is the graph canonicalization algorithm
type GraphCanonicalizationAlgorithm int32

const (
	// unspecified and invalid
	GraphCanonicalizationAlgorithm_GRAPH_CANONICALIZATION_ALGORITHM_UNSPECIFIED GraphCanonicalizationAlgorithm = 0
	// URDNA2015 graph hashing
	GraphCanonicalizationAlgorithm_GRAPH_CANONICALIZATION_ALGORITHM_URDNA2015 GraphCanonicalizationAlgorithm = 1
)

var GraphCanonicalizationAlgorithm_name = map[int32]string{
	0: "GRAPH_CANONICALIZATION_ALGORITHM_UNSPECIFIED",
	1: "GRAPH_CANONICALIZATION_ALGORITHM_URDNA2015",
}

var GraphCanonicalizationAlgorithm_value = map[string]int32{
	"GRAPH_CANONICALIZATION_ALGORITHM_UNSPECIFIED": 0,
	"GRAPH_CANONICALIZATION_ALGORITHM_URDNA2015":   1,
}

func (x GraphCanonicalizationAlgorithm) String() string {
	return proto.EnumName(GraphCanonicalizationAlgorithm_name, int32(x))
}

func (GraphCanonicalizationAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{1}
}

// GraphMerkleTree is the graph merkle tree type used for hashing, if any
type GraphMerkleTree int32

const (
	// no merkle tree
	GraphMerkleTree_GRAPH_MERKLE_TREE_NONE_UNSPECIFIED GraphMerkleTree = 0
)

var GraphMerkleTree_name = map[int32]string{
	0: "GRAPH_MERKLE_TREE_NONE_UNSPECIFIED",
}

var GraphMerkleTree_value = map[string]int32{
	"GRAPH_MERKLE_TREE_NONE_UNSPECIFIED": 0,
}

func (x GraphMerkleTree) String() string {
	return proto.EnumName(GraphMerkleTree_name, int32(x))
}

func (GraphMerkleTree) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{2}
}

// DigestAlgorithm is the hash digest algorithm
type DigestAlgorithm int32

const (
	// unspecified and invalid
	DigestAlgorithm_DIGEST_ALGORITHM_UNSPECIFIED DigestAlgorithm = 0
	// BLAKE2b-256
	DigestAlgorithm_DIGEST_ALGORITHM_BLAKE2B_256 DigestAlgorithm = 1
)

var DigestAlgorithm_name = map[int32]string{
	0: "DIGEST_ALGORITHM_UNSPECIFIED",
	1: "DIGEST_ALGORITHM_BLAKE2B_256",
}

var DigestAlgorithm_value = map[string]int32{
	"DIGEST_ALGORITHM_UNSPECIFIED": 0,
	"DIGEST_ALGORITHM_BLAKE2B_256": 1,
}

func (x DigestAlgorithm) String() string {
	return proto.EnumName(DigestAlgorithm_name, int32(x))
}

func (DigestAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{3}
}

type CompactDataset_WellknownDatatype int32

const (
	CompactDataset_DATATYPE_UNSPECIFIED   CompactDataset_WellknownDatatype = 0
	CompactDataset_DATATYPE_BOOL_FALSE    CompactDataset_WellknownDatatype = 1
	CompactDataset_DATATYPE_BOOL_TRUE     CompactDataset_WellknownDatatype = 2
	CompactDataset_DATATYPE_DECIMAL       CompactDataset_WellknownDatatype = 3
	CompactDataset_DATATYPE_INTEGER       CompactDataset_WellknownDatatype = 4
	CompactDataset_DATATYPE_STRING        CompactDataset_WellknownDatatype = 5
	CompactDataset_DATATYPE_ANY_URI       CompactDataset_WellknownDatatype = 6
	CompactDataset_DATATYPE_DATE          CompactDataset_WellknownDatatype = 7
	CompactDataset_DATATYPE_TIME          CompactDataset_WellknownDatatype = 8
	CompactDataset_DATATYPE_DATE_TIME     CompactDataset_WellknownDatatype = 9
	CompactDataset_DATATYPE_BASE64_STRING CompactDataset_WellknownDatatype = 10
	CompactDataset_DATATYPE_WKT_LITERAL   CompactDataset_WellknownDatatype = 11
)

var CompactDataset_WellknownDatatype_name = map[int32]string{
	0:  "DATATYPE_UNSPECIFIED",
	1:  "DATATYPE_BOOL_FALSE",
	2:  "DATATYPE_BOOL_TRUE",
	3:  "DATATYPE_DECIMAL",
	4:  "DATATYPE_INTEGER",
	5:  "DATATYPE_STRING",
	6:  "DATATYPE_ANY_URI",
	7:  "DATATYPE_DATE",
	8:  "DATATYPE_TIME",
	9:  "DATATYPE_DATE_TIME",
	10: "DATATYPE_BASE64_STRING",
	11: "DATATYPE_WKT_LITERAL",
}

var CompactDataset_WellknownDatatype_value = map[string]int32{
	"DATATYPE_UNSPECIFIED":   0,
	"DATATYPE_BOOL_FALSE":    1,
	"DATATYPE_BOOL_TRUE":     2,
	"DATATYPE_DECIMAL":       3,
	"DATATYPE_INTEGER":       4,
	"DATATYPE_STRING":        5,
	"DATATYPE_ANY_URI":       6,
	"DATATYPE_DATE":          7,
	"DATATYPE_TIME":          8,
	"DATATYPE_DATE_TIME":     9,
	"DATATYPE_BASE64_STRING": 10,
	"DATATYPE_WKT_LITERAL":   11,
}

func (x CompactDataset_WellknownDatatype) String() string {
	return proto.EnumName(CompactDataset_WellknownDatatype_name, int32(x))
}

func (CompactDataset_WellknownDatatype) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{3, 0}
}

// ContentHash specifies a hash based content identifier for a piece of data
type ContentHash struct {
	// sum selects the type of content hash
	//
	// Types that are valid to be assigned to Sum:
	//	*ContentHash_Raw_
	//	*ContentHash_Graph_
	Sum isContentHash_Sum `protobuf_oneof:"sum"`
}

func (m *ContentHash) Reset()         { *m = ContentHash{} }
func (m *ContentHash) String() string { return proto.CompactTextString(m) }
func (*ContentHash) ProtoMessage()    {}
func (*ContentHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{0}
}
func (m *ContentHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContentHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContentHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentHash.Merge(m, src)
}
func (m *ContentHash) XXX_Size() int {
	return m.Size()
}
func (m *ContentHash) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentHash.DiscardUnknown(m)
}

var xxx_messageInfo_ContentHash proto.InternalMessageInfo

type isContentHash_Sum interface {
	isContentHash_Sum()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ContentHash_Raw_ struct {
	Raw *ContentHash_Raw `protobuf:"bytes,1,opt,name=raw,proto3,oneof" json:"raw,omitempty"`
}
type ContentHash_Graph_ struct {
	Graph *ContentHash_Graph `protobuf:"bytes,2,opt,name=graph,proto3,oneof" json:"graph,omitempty"`
}

func (*ContentHash_Raw_) isContentHash_Sum()   {}
func (*ContentHash_Graph_) isContentHash_Sum() {}

func (m *ContentHash) GetSum() isContentHash_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (m *ContentHash) GetRaw() *ContentHash_Raw {
	if x, ok := m.GetSum().(*ContentHash_Raw_); ok {
		return x.Raw
	}
	return nil
}

func (m *ContentHash) GetGraph() *ContentHash_Graph {
	if x, ok := m.GetSum().(*ContentHash_Graph_); ok {
		return x.Graph
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ContentHash) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ContentHash_Raw_)(nil),
		(*ContentHash_Graph_)(nil),
	}
}

// Raw is the content hash type used for raw data
type ContentHash_Raw struct {
	// hash represents the hash of the data based on the specified digest_algorithm
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// digest_algorithm represents the hash digest algorithm.
	DigestAlgorithm DigestAlgorithm `protobuf:"varint,2,opt,name=digest_algorithm,json=digestAlgorithm,proto3,enum=regen.data.v1alpha2.DigestAlgorithm" json:"digest_algorithm,omitempty"`
	// media_type represents the MediaType for raw data.
	MediaType MediaType `protobuf:"varint,3,opt,name=media_type,json=mediaType,proto3,enum=regen.data.v1alpha2.MediaType" json:"media_type,omitempty"`
}

func (m *ContentHash_Raw) Reset()         { *m = ContentHash_Raw{} }
func (m *ContentHash_Raw) String() string { return proto.CompactTextString(m) }
func (*ContentHash_Raw) ProtoMessage()    {}
func (*ContentHash_Raw) Descriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{0, 0}
}
func (m *ContentHash_Raw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentHash_Raw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContentHash_Raw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContentHash_Raw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentHash_Raw.Merge(m, src)
}
func (m *ContentHash_Raw) XXX_Size() int {
	return m.Size()
}
func (m *ContentHash_Raw) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentHash_Raw.DiscardUnknown(m)
}

var xxx_messageInfo_ContentHash_Raw proto.InternalMessageInfo

func (m *ContentHash_Raw) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *ContentHash_Raw) GetDigestAlgorithm() DigestAlgorithm {
	if m != nil {
		return m.DigestAlgorithm
	}
	return DigestAlgorithm_DIGEST_ALGORITHM_UNSPECIFIED
}

func (m *ContentHash_Raw) GetMediaType() MediaType {
	if m != nil {
		return m.MediaType
	}
	return MediaType_MEDIA_TYPE_UNSPECIFIED
}

// Graph is the content hash type used for RDF graph data
type ContentHash_Graph struct {
	// hash represents the hash of the data based on the specified digest_algorithm
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// digest_algorithm represents the hash digest algorithm.
	DigestAlgorithm DigestAlgorithm `protobuf:"varint,2,opt,name=digest_algorithm,json=digestAlgorithm,proto3,enum=regen.data.v1alpha2.DigestAlgorithm" json:"digest_algorithm,omitempty"`
	// graph_canonicalization_algorithm represents the RDF graph canonicalization algorithm.
	CanonicalizationAlgorithm GraphCanonicalizationAlgorithm `protobuf:"varint,3,opt,name=canonicalization_algorithm,json=canonicalizationAlgorithm,proto3,enum=regen.data.v1alpha2.GraphCanonicalizationAlgorithm" json:"canonicalization_algorithm,omitempty"`
	// merkle_tree is the merkle tree type used for the graph hash, if any
	MerkleTree GraphMerkleTree `protobuf:"varint,4,opt,name=merkle_tree,json=merkleTree,proto3,enum=regen.data.v1alpha2.GraphMerkleTree" json:"merkle_tree,omitempty"`
}

func (m *ContentHash_Graph) Reset()         { *m = ContentHash_Graph{} }
func (m *ContentHash_Graph) String() string { return proto.CompactTextString(m) }
func (*ContentHash_Graph) ProtoMessage()    {}
func (*ContentHash_Graph) Descriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{0, 1}
}
func (m *ContentHash_Graph) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentHash_Graph) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContentHash_Graph.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContentHash_Graph) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentHash_Graph.Merge(m, src)
}
func (m *ContentHash_Graph) XXX_Size() int {
	return m.Size()
}
func (m *ContentHash_Graph) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentHash_Graph.DiscardUnknown(m)
}

var xxx_messageInfo_ContentHash_Graph proto.InternalMessageInfo

func (m *ContentHash_Graph) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *ContentHash_Graph) GetDigestAlgorithm() DigestAlgorithm {
	if m != nil {
		return m.DigestAlgorithm
	}
	return DigestAlgorithm_DIGEST_ALGORITHM_UNSPECIFIED
}

func (m *ContentHash_Graph) GetCanonicalizationAlgorithm() GraphCanonicalizationAlgorithm {
	if m != nil {
		return m.CanonicalizationAlgorithm
	}
	return GraphCanonicalizationAlgorithm_GRAPH_CANONICALIZATION_ALGORITHM_UNSPECIFIED
}

func (m *ContentHash_Graph) GetMerkleTree() GraphMerkleTree {
	if m != nil {
		return m.MerkleTree
	}
	return GraphMerkleTree_GRAPH_MERKLE_TREE_NONE_UNSPECIFIED
}

// Content is a wrapper for content stored on-chain
type Content struct {
	// sum selects the type of data
	//
	// Types that are valid to be assigned to Sum:
	//	*Content_RawData
	Sum isContent_Sum `protobuf_oneof:"sum"`
}

func (m *Content) Reset()         { *m = Content{} }
func (m *Content) String() string { return proto.CompactTextString(m) }
func (*Content) ProtoMessage()    {}
func (*Content) Descriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{1}
}
func (m *Content) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Content) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Content.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Content) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Content.Merge(m, src)
}
func (m *Content) XXX_Size() int {
	return m.Size()
}
func (m *Content) XXX_DiscardUnknown() {
	xxx_messageInfo_Content.DiscardUnknown(m)
}

var xxx_messageInfo_Content proto.InternalMessageInfo

type isContent_Sum interface {
	isContent_Sum()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Content_RawData struct {
	RawData []byte `protobuf:"bytes,1,opt,name=raw_data,json=rawData,proto3,oneof" json:"raw_data,omitempty"`
}

func (*Content_RawData) isContent_Sum() {}

func (m *Content) GetSum() isContent_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (m *Content) GetRawData() []byte {
	if x, ok := m.GetSum().(*Content_RawData); ok {
		return x.RawData
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Content) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Content_RawData)(nil),
	}
}

// SignerEntry is a signer entry wrapping a signer address and timestamp
type SignerEntry struct {
	// signer is the address of the signer
	Signer string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	// timestamp is the time at which the data was signed
	Timestamp *types.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *SignerEntry) Reset()         { *m = SignerEntry{} }
func (m *SignerEntry) String() string { return proto.CompactTextString(m) }
func (*SignerEntry) ProtoMessage()    {}
func (*SignerEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{2}
}
func (m *SignerEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignerEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignerEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignerEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignerEntry.Merge(m, src)
}
func (m *SignerEntry) XXX_Size() int {
	return m.Size()
}
func (m *SignerEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_SignerEntry.DiscardUnknown(m)
}

var xxx_messageInfo_SignerEntry proto.InternalMessageInfo

func (m *SignerEntry) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *SignerEntry) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type CompactDataset struct {
	Nodes   []*CompactDataset_Node `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	NewIris []string               `protobuf:"bytes,2,rep,name=new_iris,json=newIris,proto3" json:"new_iris,omitempty"`
}

func (m *CompactDataset) Reset()         { *m = CompactDataset{} }
func (m *CompactDataset) String() string { return proto.CompactTextString(m) }
func (*CompactDataset) ProtoMessage()    {}
func (*CompactDataset) Descriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{3}
}
func (m *CompactDataset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactDataset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactDataset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactDataset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactDataset.Merge(m, src)
}
func (m *CompactDataset) XXX_Size() int {
	return m.Size()
}
func (m *CompactDataset) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactDataset.DiscardUnknown(m)
}

var xxx_messageInfo_CompactDataset proto.InternalMessageInfo

func (m *CompactDataset) GetNodes() []*CompactDataset_Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *CompactDataset) GetNewIris() []string {
	if m != nil {
		return m.NewIris
	}
	return nil
}

type CompactDataset_Node struct {
	// Types that are valid to be assigned to Subject:
	//	*CompactDataset_Node_InternalId
	//	*CompactDataset_Node_LocalRef
	Subject    isCompactDataset_Node_Subject `protobuf_oneof:"subject"`
	Properties []*CompactDataset_Properties  `protobuf:"bytes,3,rep,name=properties,proto3" json:"properties,omitempty"`
}

func (m *CompactDataset_Node) Reset()         { *m = CompactDataset_Node{} }
func (m *CompactDataset_Node) String() string { return proto.CompactTextString(m) }
func (*CompactDataset_Node) ProtoMessage()    {}
func (*CompactDataset_Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{3, 0}
}
func (m *CompactDataset_Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactDataset_Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactDataset_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactDataset_Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactDataset_Node.Merge(m, src)
}
func (m *CompactDataset_Node) XXX_Size() int {
	return m.Size()
}
func (m *CompactDataset_Node) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactDataset_Node.DiscardUnknown(m)
}

var xxx_messageInfo_CompactDataset_Node proto.InternalMessageInfo

type isCompactDataset_Node_Subject interface {
	isCompactDataset_Node_Subject()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CompactDataset_Node_InternalId struct {
	InternalId []byte `protobuf:"bytes,1,opt,name=internal_id,json=internalId,proto3,oneof" json:"internal_id,omitempty"`
}
type CompactDataset_Node_LocalRef struct {
	LocalRef int32 `protobuf:"zigzag32,2,opt,name=local_ref,json=localRef,proto3,oneof" json:"local_ref,omitempty"`
}

func (*CompactDataset_Node_InternalId) isCompactDataset_Node_Subject() {}
func (*CompactDataset_Node_LocalRef) isCompactDataset_Node_Subject()   {}

func (m *CompactDataset_Node) GetSubject() isCompactDataset_Node_Subject {
	if m != nil {
		return m.Subject
	}
	return nil
}

func (m *CompactDataset_Node) GetInternalId() []byte {
	if x, ok := m.GetSubject().(*CompactDataset_Node_InternalId); ok {
		return x.InternalId
	}
	return nil
}

func (m *CompactDataset_Node) GetLocalRef() int32 {
	if x, ok := m.GetSubject().(*CompactDataset_Node_LocalRef); ok {
		return x.LocalRef
	}
	return 0
}

func (m *CompactDataset_Node) GetProperties() []*CompactDataset_Properties {
	if m != nil {
		return m.Properties
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CompactDataset_Node) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CompactDataset_Node_InternalId)(nil),
		(*CompactDataset_Node_LocalRef)(nil),
	}
}

type CompactDataset_Properties struct {
	// Types that are valid to be assigned to Predicate:
	//	*CompactDataset_Properties_InternalId
	//	*CompactDataset_Properties_LocalRef
	Predicate isCompactDataset_Properties_Predicate `protobuf_oneof:"predicate"`
	Objects   []*CompactDataset_ObjectGraph         `protobuf:"bytes,3,rep,name=objects,proto3" json:"objects,omitempty"`
}

func (m *CompactDataset_Properties) Reset()         { *m = CompactDataset_Properties{} }
func (m *CompactDataset_Properties) String() string { return proto.CompactTextString(m) }
func (*CompactDataset_Properties) ProtoMessage()    {}
func (*CompactDataset_Properties) Descriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{3, 1}
}
func (m *CompactDataset_Properties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactDataset_Properties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactDataset_Properties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactDataset_Properties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactDataset_Properties.Merge(m, src)
}
func (m *CompactDataset_Properties) XXX_Size() int {
	return m.Size()
}
func (m *CompactDataset_Properties) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactDataset_Properties.DiscardUnknown(m)
}

var xxx_messageInfo_CompactDataset_Properties proto.InternalMessageInfo

type isCompactDataset_Properties_Predicate interface {
	isCompactDataset_Properties_Predicate()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CompactDataset_Properties_InternalId struct {
	InternalId []byte `protobuf:"bytes,1,opt,name=internal_id,json=internalId,proto3,oneof" json:"internal_id,omitempty"`
}
type CompactDataset_Properties_LocalRef struct {
	LocalRef int32 `protobuf:"zigzag32,2,opt,name=local_ref,json=localRef,proto3,oneof" json:"local_ref,omitempty"`
}

func (*CompactDataset_Properties_InternalId) isCompactDataset_Properties_Predicate() {}
func (*CompactDataset_Properties_LocalRef) isCompactDataset_Properties_Predicate()   {}

func (m *CompactDataset_Properties) GetPredicate() isCompactDataset_Properties_Predicate {
	if m != nil {
		return m.Predicate
	}
	return nil
}

func (m *CompactDataset_Properties) GetInternalId() []byte {
	if x, ok := m.GetPredicate().(*CompactDataset_Properties_InternalId); ok {
		return x.InternalId
	}
	return nil
}

func (m *CompactDataset_Properties) GetLocalRef() int32 {
	if x, ok := m.GetPredicate().(*CompactDataset_Properties_LocalRef); ok {
		return x.LocalRef
	}
	return 0
}

func (m *CompactDataset_Properties) GetObjects() []*CompactDataset_ObjectGraph {
	if m != nil {
		return m.Objects
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CompactDataset_Properties) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CompactDataset_Properties_InternalId)(nil),
		(*CompactDataset_Properties_LocalRef)(nil),
	}
}

type CompactDataset_ObjectGraph struct {
	// Types that are valid to be assigned to Sum:
	//	*CompactDataset_ObjectGraph_ObjectInternalId
	//	*CompactDataset_ObjectGraph_ObjectLocalRef
	//	*CompactDataset_ObjectGraph_WellKnownDatatype
	//	*CompactDataset_ObjectGraph_DataTypeInternalId
	//	*CompactDataset_ObjectGraph_DataTypeLocalRef
	Sum    isCompactDataset_ObjectGraph_Sum      `protobuf_oneof:"sum"`
	Lang   string                                `protobuf:"bytes,6,opt,name=lang,proto3" json:"lang,omitempty"`
	Graphs []*CompactDataset_ObjectGraph_GraphID `protobuf:"bytes,7,rep,name=graphs,proto3" json:"graphs,omitempty"`
	// Types that are valid to be assigned to LiteralValue:
	//	*CompactDataset_ObjectGraph_StrValue
	LiteralValue isCompactDataset_ObjectGraph_LiteralValue `protobuf_oneof:"literal_value"`
}

func (m *CompactDataset_ObjectGraph) Reset()         { *m = CompactDataset_ObjectGraph{} }
func (m *CompactDataset_ObjectGraph) String() string { return proto.CompactTextString(m) }
func (*CompactDataset_ObjectGraph) ProtoMessage()    {}
func (*CompactDataset_ObjectGraph) Descriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{3, 2}
}
func (m *CompactDataset_ObjectGraph) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactDataset_ObjectGraph) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactDataset_ObjectGraph.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactDataset_ObjectGraph) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactDataset_ObjectGraph.Merge(m, src)
}
func (m *CompactDataset_ObjectGraph) XXX_Size() int {
	return m.Size()
}
func (m *CompactDataset_ObjectGraph) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactDataset_ObjectGraph.DiscardUnknown(m)
}

var xxx_messageInfo_CompactDataset_ObjectGraph proto.InternalMessageInfo

type isCompactDataset_ObjectGraph_Sum interface {
	isCompactDataset_ObjectGraph_Sum()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCompactDataset_ObjectGraph_LiteralValue interface {
	isCompactDataset_ObjectGraph_LiteralValue()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CompactDataset_ObjectGraph_ObjectInternalId struct {
	ObjectInternalId []byte `protobuf:"bytes,1,opt,name=object_internal_id,json=objectInternalId,proto3,oneof" json:"object_internal_id,omitempty"`
}
type CompactDataset_ObjectGraph_ObjectLocalRef struct {
	ObjectLocalRef int32 `protobuf:"zigzag32,2,opt,name=object_local_ref,json=objectLocalRef,proto3,oneof" json:"object_local_ref,omitempty"`
}
type CompactDataset_ObjectGraph_WellKnownDatatype struct {
	WellKnownDatatype CompactDataset_WellknownDatatype `protobuf:"varint,3,opt,name=well_known_datatype,json=wellKnownDatatype,proto3,enum=regen.data.v1alpha2.CompactDataset_WellknownDatatype,oneof" json:"well_known_datatype,omitempty"`
}
type CompactDataset_ObjectGraph_DataTypeInternalId struct {
	DataTypeInternalId []byte `protobuf:"bytes,4,opt,name=data_type_internal_id,json=dataTypeInternalId,proto3,oneof" json:"data_type_internal_id,omitempty"`
}
type CompactDataset_ObjectGraph_DataTypeLocalRef struct {
	DataTypeLocalRef int32 `protobuf:"zigzag32,5,opt,name=data_type_local_ref,json=dataTypeLocalRef,proto3,oneof" json:"data_type_local_ref,omitempty"`
}
type CompactDataset_ObjectGraph_StrValue struct {
	StrValue string `protobuf:"bytes,8,opt,name=str_value,json=strValue,proto3,oneof" json:"str_value,omitempty"`
}

func (*CompactDataset_ObjectGraph_ObjectInternalId) isCompactDataset_ObjectGraph_Sum()   {}
func (*CompactDataset_ObjectGraph_ObjectLocalRef) isCompactDataset_ObjectGraph_Sum()     {}
func (*CompactDataset_ObjectGraph_WellKnownDatatype) isCompactDataset_ObjectGraph_Sum()  {}
func (*CompactDataset_ObjectGraph_DataTypeInternalId) isCompactDataset_ObjectGraph_Sum() {}
func (*CompactDataset_ObjectGraph_DataTypeLocalRef) isCompactDataset_ObjectGraph_Sum()   {}
func (*CompactDataset_ObjectGraph_StrValue) isCompactDataset_ObjectGraph_LiteralValue()  {}

func (m *CompactDataset_ObjectGraph) GetSum() isCompactDataset_ObjectGraph_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}
func (m *CompactDataset_ObjectGraph) GetLiteralValue() isCompactDataset_ObjectGraph_LiteralValue {
	if m != nil {
		return m.LiteralValue
	}
	return nil
}

func (m *CompactDataset_ObjectGraph) GetObjectInternalId() []byte {
	if x, ok := m.GetSum().(*CompactDataset_ObjectGraph_ObjectInternalId); ok {
		return x.ObjectInternalId
	}
	return nil
}

func (m *CompactDataset_ObjectGraph) GetObjectLocalRef() int32 {
	if x, ok := m.GetSum().(*CompactDataset_ObjectGraph_ObjectLocalRef); ok {
		return x.ObjectLocalRef
	}
	return 0
}

func (m *CompactDataset_ObjectGraph) GetWellKnownDatatype() CompactDataset_WellknownDatatype {
	if x, ok := m.GetSum().(*CompactDataset_ObjectGraph_WellKnownDatatype); ok {
		return x.WellKnownDatatype
	}
	return CompactDataset_DATATYPE_UNSPECIFIED
}

func (m *CompactDataset_ObjectGraph) GetDataTypeInternalId() []byte {
	if x, ok := m.GetSum().(*CompactDataset_ObjectGraph_DataTypeInternalId); ok {
		return x.DataTypeInternalId
	}
	return nil
}

func (m *CompactDataset_ObjectGraph) GetDataTypeLocalRef() int32 {
	if x, ok := m.GetSum().(*CompactDataset_ObjectGraph_DataTypeLocalRef); ok {
		return x.DataTypeLocalRef
	}
	return 0
}

func (m *CompactDataset_ObjectGraph) GetLang() string {
	if m != nil {
		return m.Lang
	}
	return ""
}

func (m *CompactDataset_ObjectGraph) GetGraphs() []*CompactDataset_ObjectGraph_GraphID {
	if m != nil {
		return m.Graphs
	}
	return nil
}

func (m *CompactDataset_ObjectGraph) GetStrValue() string {
	if x, ok := m.GetLiteralValue().(*CompactDataset_ObjectGraph_StrValue); ok {
		return x.StrValue
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CompactDataset_ObjectGraph) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CompactDataset_ObjectGraph_ObjectInternalId)(nil),
		(*CompactDataset_ObjectGraph_ObjectLocalRef)(nil),
		(*CompactDataset_ObjectGraph_WellKnownDatatype)(nil),
		(*CompactDataset_ObjectGraph_DataTypeInternalId)(nil),
		(*CompactDataset_ObjectGraph_DataTypeLocalRef)(nil),
		(*CompactDataset_ObjectGraph_StrValue)(nil),
	}
}

type CompactDataset_ObjectGraph_GraphID struct {
	// Types that are valid to be assigned to Graph:
	//	*CompactDataset_ObjectGraph_GraphID_InternalId
	//	*CompactDataset_ObjectGraph_GraphID_LocalRef
	Graph isCompactDataset_ObjectGraph_GraphID_Graph `protobuf_oneof:"graph"`
}

func (m *CompactDataset_ObjectGraph_GraphID) Reset()         { *m = CompactDataset_ObjectGraph_GraphID{} }
func (m *CompactDataset_ObjectGraph_GraphID) String() string { return proto.CompactTextString(m) }
func (*CompactDataset_ObjectGraph_GraphID) ProtoMessage()    {}
func (*CompactDataset_ObjectGraph_GraphID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e68eefb44eeab1df, []int{3, 2, 0}
}
func (m *CompactDataset_ObjectGraph_GraphID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactDataset_ObjectGraph_GraphID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactDataset_ObjectGraph_GraphID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactDataset_ObjectGraph_GraphID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactDataset_ObjectGraph_GraphID.Merge(m, src)
}
func (m *CompactDataset_ObjectGraph_GraphID) XXX_Size() int {
	return m.Size()
}
func (m *CompactDataset_ObjectGraph_GraphID) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactDataset_ObjectGraph_GraphID.DiscardUnknown(m)
}

var xxx_messageInfo_CompactDataset_ObjectGraph_GraphID proto.InternalMessageInfo

type isCompactDataset_ObjectGraph_GraphID_Graph interface {
	isCompactDataset_ObjectGraph_GraphID_Graph()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CompactDataset_ObjectGraph_GraphID_InternalId struct {
	InternalId []byte `protobuf:"bytes,1,opt,name=internal_id,json=internalId,proto3,oneof" json:"internal_id,omitempty"`
}
type CompactDataset_ObjectGraph_GraphID_LocalRef struct {
	LocalRef int32 `protobuf:"zigzag32,2,opt,name=local_ref,json=localRef,proto3,oneof" json:"local_ref,omitempty"`
}

func (*CompactDataset_ObjectGraph_GraphID_InternalId) isCompactDataset_ObjectGraph_GraphID_Graph() {}
func (*CompactDataset_ObjectGraph_GraphID_LocalRef) isCompactDataset_ObjectGraph_GraphID_Graph()   {}

func (m *CompactDataset_ObjectGraph_GraphID) GetGraph() isCompactDataset_ObjectGraph_GraphID_Graph {
	if m != nil {
		return m.Graph
	}
	return nil
}

func (m *CompactDataset_ObjectGraph_GraphID) GetInternalId() []byte {
	if x, ok := m.GetGraph().(*CompactDataset_ObjectGraph_GraphID_InternalId); ok {
		return x.InternalId
	}
	return nil
}

func (m *CompactDataset_ObjectGraph_GraphID) GetLocalRef() int32 {
	if x, ok := m.GetGraph().(*CompactDataset_ObjectGraph_GraphID_LocalRef); ok {
		return x.LocalRef
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CompactDataset_ObjectGraph_GraphID) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CompactDataset_ObjectGraph_GraphID_InternalId)(nil),
		(*CompactDataset_ObjectGraph_GraphID_LocalRef)(nil),
	}
}

func init() {
	proto.RegisterEnum("regen.data.v1alpha2.MediaType", MediaType_name, MediaType_value)
	proto.RegisterEnum("regen.data.v1alpha2.GraphCanonicalizationAlgorithm", GraphCanonicalizationAlgorithm_name, GraphCanonicalizationAlgorithm_value)
	proto.RegisterEnum("regen.data.v1alpha2.GraphMerkleTree", GraphMerkleTree_name, GraphMerkleTree_value)
	proto.RegisterEnum("regen.data.v1alpha2.DigestAlgorithm", DigestAlgorithm_name, DigestAlgorithm_value)
	proto.RegisterEnum("regen.data.v1alpha2.CompactDataset_WellknownDatatype", CompactDataset_WellknownDatatype_name, CompactDataset_WellknownDatatype_value)
	proto.RegisterType((*ContentHash)(nil), "regen.data.v1alpha2.ContentHash")
	proto.RegisterType((*ContentHash_Raw)(nil), "regen.data.v1alpha2.ContentHash.Raw")
	proto.RegisterType((*ContentHash_Graph)(nil), "regen.data.v1alpha2.ContentHash.Graph")
	proto.RegisterType((*Content)(nil), "regen.data.v1alpha2.Content")
	proto.RegisterType((*SignerEntry)(nil), "regen.data.v1alpha2.SignerEntry")
	proto.RegisterType((*CompactDataset)(nil), "regen.data.v1alpha2.CompactDataset")
	proto.RegisterType((*CompactDataset_Node)(nil), "regen.data.v1alpha2.CompactDataset.Node")
	proto.RegisterType((*CompactDataset_Properties)(nil), "regen.data.v1alpha2.CompactDataset.Properties")
	proto.RegisterType((*CompactDataset_ObjectGraph)(nil), "regen.data.v1alpha2.CompactDataset.ObjectGraph")
	proto.RegisterType((*CompactDataset_ObjectGraph_GraphID)(nil), "regen.data.v1alpha2.CompactDataset.ObjectGraph.GraphID")
}

func init() { proto.RegisterFile("regen/data/v1alpha2/types.proto", fileDescriptor_e68eefb44eeab1df) }

var fileDescriptor_e68eefb44eeab1df = []byte{
	// 1238 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x4d, 0x6f, 0xdb, 0x46,
	0x10, 0x15, 0x2d, 0xd9, 0xb2, 0x46, 0x8d, 0xbd, 0x5e, 0x27, 0x8e, 0xa2, 0xb6, 0x8a, 0xe3, 0x16,
	0x81, 0x61, 0x24, 0x54, 0xe2, 0x7c, 0x34, 0x3d, 0xb4, 0x00, 0x25, 0x51, 0x14, 0x63, 0x89, 0x12,
	0x56, 0xb4, 0xf3, 0x71, 0x21, 0xd6, 0xd2, 0x46, 0x62, 0x43, 0x91, 0xc2, 0x92, 0x8e, 0x9a, 0x1e,
	0x7b, 0xeb, 0xad, 0x40, 0x7f, 0x42, 0x81, 0x16, 0xe9, 0x2f, 0xe9, 0x31, 0xc7, 0x1e, 0x8b, 0xa4,
	0x3f, 0xa4, 0xe0, 0x52, 0x9f, 0x8c, 0x9d, 0xb8, 0x68, 0xd1, 0xdb, 0xf2, 0xcd, 0x7b, 0x33, 0x6f,
	0xb8, 0xc3, 0x5d, 0xc2, 0x55, 0xce, 0x7a, 0xcc, 0x2d, 0x76, 0x69, 0x40, 0x8b, 0x2f, 0x6e, 0x53,
	0x67, 0xd8, 0xa7, 0xfb, 0xc5, 0xe0, 0xe5, 0x90, 0xf9, 0xf2, 0x90, 0x7b, 0x81, 0x87, 0x37, 0x05,
	0x41, 0x0e, 0x09, 0xf2, 0x84, 0x90, 0xbf, 0xda, 0xf3, 0xbc, 0x9e, 0xc3, 0x8a, 0x82, 0x72, 0x7c,
	0xf2, 0xac, 0x18, 0xd8, 0x03, 0xe6, 0x07, 0x74, 0x30, 0x8c, 0x54, 0xf9, 0x42, 0x9c, 0xd0, 0x3d,
	0xe1, 0x34, 0xb0, 0x3d, 0x37, 0x8a, 0xef, 0xfc, 0x95, 0x82, 0x6c, 0xd9, 0x73, 0x03, 0xe6, 0x06,
	0x35, 0xea, 0xf7, 0xf1, 0x03, 0x48, 0x72, 0x3a, 0xca, 0x49, 0xdb, 0xd2, 0x6e, 0x76, 0xff, 0x73,
	0xf9, 0x94, 0x9a, 0xf2, 0x1c, 0x5d, 0x26, 0x74, 0x54, 0x4b, 0x90, 0x50, 0x82, 0xbf, 0x86, 0xe5,
	0x1e, 0xa7, 0xc3, 0x7e, 0x6e, 0x49, 0x68, 0xaf, 0x7f, 0x50, 0xab, 0x85, 0xec, 0x5a, 0x82, 0x44,
	0xb2, 0xfc, 0x2b, 0x09, 0x92, 0x84, 0x8e, 0x30, 0x86, 0x54, 0x9f, 0xfa, 0x7d, 0x61, 0xe1, 0x23,
	0x22, 0xd6, 0xb8, 0x09, 0xa8, 0x6b, 0xf7, 0x98, 0x1f, 0x58, 0xd4, 0xe9, 0x79, 0xdc, 0x0e, 0xfa,
	0x03, 0x51, 0x66, 0xed, 0x0c, 0x8b, 0x15, 0x41, 0x56, 0x26, 0x5c, 0xb2, 0xde, 0x5d, 0x04, 0xf0,
	0x57, 0x00, 0x03, 0xd6, 0xb5, 0xa9, 0x15, 0xbe, 0xe1, 0x5c, 0x52, 0xa4, 0x2a, 0x9c, 0x9a, 0xaa,
	0x11, 0xd2, 0xcc, 0x97, 0x43, 0x46, 0x32, 0x83, 0xc9, 0x32, 0xff, 0xeb, 0x12, 0x2c, 0x0b, 0xfb,
	0xff, 0x8f, 0x5b, 0x0e, 0xf9, 0x0e, 0x75, 0x3d, 0xd7, 0xee, 0x50, 0xc7, 0xfe, 0x4e, 0x6c, 0xdf,
	0x5c, 0xea, 0xc8, 0xfd, 0x9d, 0x53, 0x53, 0x0b, 0x93, 0xe5, 0x98, 0x76, 0x56, 0xe9, 0x4a, 0xe7,
	0xac, 0x10, 0x56, 0x21, 0x3b, 0x60, 0xfc, 0xb9, 0xc3, 0xac, 0x80, 0x33, 0x96, 0x4b, 0xbd, 0xc7,
	0xbf, 0x28, 0xd2, 0x10, 0x64, 0x93, 0x33, 0x46, 0x60, 0x30, 0x5d, 0x97, 0x96, 0x21, 0xe9, 0x9f,
	0x0c, 0x76, 0x6e, 0x42, 0x7a, 0xbc, 0xf5, 0xf8, 0x63, 0x58, 0xe5, 0x74, 0x64, 0x85, 0x29, 0xa2,
	0xb7, 0x56, 0x4b, 0x90, 0x34, 0xa7, 0xa3, 0x0a, 0x0d, 0xe8, 0x84, 0x6e, 0x41, 0xb6, 0x6d, 0xf7,
	0x5c, 0xc6, 0x55, 0x37, 0xe0, 0x2f, 0xf1, 0x16, 0xac, 0xf8, 0xe2, 0x51, 0x08, 0x32, 0x64, 0xfc,
	0x84, 0x1f, 0x40, 0x66, 0x3a, 0xef, 0xe3, 0xb1, 0xcb, 0xcb, 0xd1, 0xc0, 0xcb, 0x93, 0x81, 0x97,
	0xcd, 0x09, 0x83, 0xcc, 0xc8, 0x3b, 0x3f, 0x01, 0xac, 0x95, 0xbd, 0xc1, 0x90, 0x76, 0x82, 0xb0,
	0xae, 0xcf, 0x82, 0x70, 0x7e, 0x5d, 0xaf, 0xcb, 0xfc, 0x9c, 0xb4, 0x9d, 0xdc, 0xcd, 0xee, 0xef,
	0x9e, 0x31, 0xbf, 0xf3, 0x1a, 0xd9, 0xf0, 0xba, 0x8c, 0x44, 0x32, 0x7c, 0x05, 0x56, 0x5d, 0x36,
	0xb2, 0x6c, 0x6e, 0xfb, 0xb9, 0xa5, 0xed, 0xe4, 0x6e, 0x86, 0xa4, 0x5d, 0x36, 0xd2, 0xb9, 0xed,
	0xe7, 0x7f, 0x96, 0x20, 0x15, 0x52, 0xf1, 0x35, 0xc8, 0xda, 0x6e, 0xc0, 0xb8, 0x4b, 0x1d, 0xcb,
	0xee, 0x4e, 0xdb, 0x87, 0x09, 0xa8, 0x77, 0xf1, 0xa7, 0x90, 0x71, 0xbc, 0x0e, 0x75, 0x2c, 0xce,
	0x9e, 0x89, 0x9e, 0x36, 0x6a, 0x09, 0xb2, 0x2a, 0x20, 0xc2, 0x9e, 0x61, 0x03, 0x60, 0xc8, 0xbd,
	0x21, 0xe3, 0x81, 0xcd, 0xfc, 0x5c, 0x52, 0x58, 0x95, 0xcf, 0x63, 0xb5, 0x35, 0x55, 0x91, 0xb9,
	0x0c, 0xa5, 0x0c, 0xa4, 0xfd, 0x93, 0xe3, 0x6f, 0x58, 0x27, 0xc8, 0xff, 0x22, 0x01, 0xcc, 0x58,
	0xff, 0x81, 0x57, 0x1d, 0xd2, 0x9e, 0x48, 0x3d, 0x31, 0x5a, 0x3c, 0x8f, 0xd1, 0xa6, 0x90, 0x88,
	0x99, 0x22, 0x13, 0x7d, 0x29, 0x0b, 0x99, 0x21, 0x67, 0x5d, 0xbb, 0x43, 0x03, 0x96, 0xff, 0x2d,
	0x05, 0xd9, 0x39, 0x16, 0x96, 0x01, 0x47, 0x3c, 0xeb, 0x34, 0xc3, 0x28, 0x8a, 0xe9, 0x33, 0xdb,
	0x7b, 0x30, 0xc6, 0xac, 0x77, 0xdd, 0xaf, 0x45, 0x91, 0xfa, 0xa4, 0x87, 0x1e, 0x6c, 0x8e, 0x98,
	0xe3, 0x58, 0xcf, 0x5d, 0x6f, 0xe4, 0x8a, 0xa1, 0x9d, 0x3b, 0x31, 0xee, 0x9d, 0xa7, 0x9f, 0x47,
	0xcc, 0x71, 0x84, 0xba, 0x32, 0x16, 0xd7, 0x12, 0x64, 0x23, 0xcc, 0x79, 0x30, 0x0f, 0xe2, 0x3b,
	0x70, 0x29, 0x4c, 0x23, 0x0e, 0xa4, 0x85, 0x3e, 0x52, 0xe3, 0x3e, 0x70, 0x18, 0x0e, 0x4f, 0x9f,
	0xb9, 0x4e, 0x8a, 0xb0, 0x39, 0x13, 0xcd, 0x9a, 0x59, 0x1e, 0x37, 0x83, 0x26, 0x92, 0x69, 0x3b,
	0x18, 0x52, 0x0e, 0x75, 0x7b, 0xb9, 0x15, 0xf1, 0x1d, 0x89, 0x35, 0x6e, 0xc2, 0x8a, 0x38, 0x81,
	0xfd, 0x5c, 0x5a, 0xec, 0xd2, 0x17, 0xff, 0x70, 0x97, 0xa2, 0xef, 0x5f, 0xaf, 0x90, 0x71, 0x9a,
	0x70, 0x2c, 0xfc, 0x80, 0x5b, 0x2f, 0xa8, 0x73, 0xc2, 0x72, 0xab, 0x61, 0xa5, 0x9a, 0x44, 0x56,
	0xfd, 0x80, 0x1f, 0x85, 0x48, 0xde, 0x84, 0xf4, 0x58, 0xf1, 0xef, 0x67, 0xac, 0x94, 0x1e, 0xdf,
	0x3a, 0xe3, 0x93, 0xa3, 0xb4, 0x0e, 0x17, 0x1c, 0x3b, 0x60, 0x9c, 0x3a, 0x51, 0xfd, 0x9d, 0x57,
	0x4b, 0xb0, 0xf1, 0xce, 0x16, 0xe0, 0x1c, 0x5c, 0xac, 0x28, 0xa6, 0x62, 0x3e, 0x69, 0xa9, 0xd6,
	0xa1, 0xd1, 0x6e, 0xa9, 0x65, 0xbd, 0xaa, 0xab, 0x15, 0x94, 0xc0, 0x97, 0x61, 0x73, 0x1a, 0x29,
	0x35, 0x9b, 0x75, 0xab, 0xaa, 0xd4, 0xdb, 0x2a, 0x92, 0xf0, 0x16, 0xe0, 0xc5, 0x80, 0x49, 0x0e,
	0x55, 0xb4, 0x84, 0x2f, 0x02, 0x9a, 0xe2, 0x15, 0xb5, 0xac, 0x37, 0x94, 0x3a, 0x4a, 0x2e, 0xa0,
	0xba, 0x61, 0xaa, 0x9a, 0x4a, 0x50, 0x0a, 0x6f, 0xc2, 0xfa, 0x14, 0x6d, 0x9b, 0x44, 0x37, 0x34,
	0xb4, 0xbc, 0x40, 0x55, 0x8c, 0x27, 0xd6, 0x21, 0xd1, 0xd1, 0x0a, 0xde, 0x80, 0x0b, 0xb3, 0xb4,
	0x8a, 0xa9, 0xa2, 0xf4, 0x02, 0x64, 0xea, 0x0d, 0x15, 0xad, 0x2e, 0x98, 0x0a, 0x59, 0x11, 0x9e,
	0xc1, 0x79, 0xd8, 0x9a, 0x99, 0x55, 0xda, 0xea, 0xfd, 0xbb, 0x93, 0x7a, 0xb0, 0xd0, 0xfb, 0xa3,
	0x03, 0xd3, 0xaa, 0xeb, 0xa6, 0x4a, 0x94, 0x3a, 0xca, 0xee, 0xfd, 0x90, 0x84, 0xcc, 0xf4, 0xbe,
	0x0b, 0x73, 0x34, 0xd4, 0x8a, 0xae, 0x58, 0xa7, 0xbc, 0xa5, 0x2b, 0x70, 0x69, 0x2e, 0x66, 0xaa,
	0x8f, 0x4d, 0xab, 0x55, 0x57, 0x74, 0x03, 0x49, 0x61, 0x8f, 0x73, 0xa1, 0x87, 0xed, 0xa6, 0x81,
	0x96, 0x30, 0x86, 0xb5, 0x39, 0xb0, 0xdc, 0x3e, 0x42, 0xc9, 0x18, 0xf6, 0xb8, 0x51, 0x47, 0xa9,
	0x18, 0xd6, 0xaa, 0x54, 0xd1, 0x72, 0x2c, 0xa1, 0xa9, 0x57, 0xab, 0x08, 0xc5, 0x88, 0x0f, 0x5b,
	0x1a, 0xda, 0x88, 0x8b, 0x0d, 0x0d, 0xe1, 0x18, 0xd6, 0x3e, 0xd2, 0xd0, 0x66, 0x2c, 0xe1, 0x23,
	0xb5, 0xd4, 0x42, 0x17, 0x63, 0xa0, 0x72, 0xa4, 0x57, 0xd1, 0xa5, 0x98, 0x5a, 0xd3, 0xab, 0x68,
	0x2b, 0x4e, 0x0c, 0xcb, 0x5c, 0x8e, 0x81, 0x8d, 0x96, 0xaa, 0xa1, 0xed, 0x98, 0xba, 0xd1, 0xba,
	0x8b, 0xae, 0xbd, 0x5b, 0xbb, 0x81, 0x76, 0x62, 0xc4, 0xa6, 0xa6, 0xa1, 0xcf, 0xf6, 0xbe, 0x97,
	0xa0, 0xf0, 0xfe, 0xdb, 0x1b, 0xdf, 0x82, 0x1b, 0x1a, 0x51, 0x5a, 0x35, 0xab, 0xac, 0x18, 0x4d,
	0x43, 0x2f, 0x2b, 0x75, 0xfd, 0xa9, 0x62, 0xea, 0x4d, 0xc3, 0x52, 0xea, 0x5a, 0x93, 0xe8, 0x66,
	0xad, 0x11, 0xdb, 0x36, 0x19, 0xf6, 0x3e, 0xac, 0x20, 0x15, 0x43, 0xd9, 0xbf, 0x75, 0xfb, 0x1e,
	0x92, 0xf6, 0xbe, 0x84, 0xf5, 0xd8, 0xe5, 0x8e, 0xaf, 0xc3, 0x4e, 0x94, 0xa2, 0xa1, 0x92, 0x83,
	0xba, 0x6a, 0x99, 0x44, 0x55, 0x2d, 0xa3, 0x69, 0xc4, 0x26, 0x64, 0xef, 0x10, 0xd6, 0x63, 0xff,
	0x35, 0x78, 0x1b, 0x3e, 0xa9, 0xe8, 0x9a, 0xda, 0x36, 0xcf, 0xf4, 0x77, 0x1a, 0xa3, 0x54, 0x57,
	0x0e, 0xd4, 0xfd, 0x92, 0xb5, 0x7f, 0xef, 0x3e, 0x92, 0x4a, 0xd5, 0xdf, 0xdf, 0x14, 0xa4, 0xd7,
	0x6f, 0x0a, 0xd2, 0x9f, 0x6f, 0x0a, 0xd2, 0x8f, 0x6f, 0x0b, 0x89, 0xd7, 0x6f, 0x0b, 0x89, 0x3f,
	0xde, 0x16, 0x12, 0x4f, 0x6f, 0xf4, 0xec, 0xa0, 0x7f, 0x72, 0x2c, 0x77, 0xbc, 0x41, 0x51, 0x1c,
	0x60, 0x37, 0x5d, 0x16, 0x8c, 0x3c, 0xfe, 0x7c, 0xfc, 0xe4, 0xb0, 0x6e, 0x8f, 0xf1, 0xe2, 0xb7,
	0xe2, 0x17, 0xfb, 0x78, 0x45, 0xfc, 0x1f, 0xdc, 0xf9, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xfd, 0xfd,
	0x72, 0xcb, 0x77, 0x0b, 0x00, 0x00,
}

func (m *ContentHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sum != nil {
		{
			size := m.Sum.Size()
			i -= size
			if _, err := m.Sum.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ContentHash_Raw_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentHash_Raw_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Raw != nil {
		{
			size, err := m.Raw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ContentHash_Graph_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentHash_Graph_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Graph != nil {
		{
			size, err := m.Graph.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ContentHash_Raw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentHash_Raw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentHash_Raw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MediaType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MediaType))
		i--
		dAtA[i] = 0x18
	}
	if m.DigestAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DigestAlgorithm))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContentHash_Graph) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentHash_Graph) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentHash_Graph) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MerkleTree != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MerkleTree))
		i--
		dAtA[i] = 0x20
	}
	if m.CanonicalizationAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CanonicalizationAlgorithm))
		i--
		dAtA[i] = 0x18
	}
	if m.DigestAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DigestAlgorithm))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Content) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Content) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Content) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sum != nil {
		{
			size := m.Sum.Size()
			i -= size
			if _, err := m.Sum.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Content_RawData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Content_RawData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RawData != nil {
		i -= len(m.RawData)
		copy(dAtA[i:], m.RawData)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RawData)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SignerEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignerEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignerEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CompactDataset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactDataset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewIris) > 0 {
		for iNdEx := len(m.NewIris) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NewIris[iNdEx])
			copy(dAtA[i:], m.NewIris[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.NewIris[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CompactDataset_Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactDataset_Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Properties) > 0 {
		for iNdEx := len(m.Properties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Properties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Subject != nil {
		{
			size := m.Subject.Size()
			i -= size
			if _, err := m.Subject.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CompactDataset_Node_InternalId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_Node_InternalId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InternalId != nil {
		i -= len(m.InternalId)
		copy(dAtA[i:], m.InternalId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InternalId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CompactDataset_Node_LocalRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_Node_LocalRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64((uint32(m.LocalRef)<<1)^uint32((m.LocalRef>>31))))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *CompactDataset_Properties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactDataset_Properties) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_Properties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for iNdEx := len(m.Objects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Objects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Predicate != nil {
		{
			size := m.Predicate.Size()
			i -= size
			if _, err := m.Predicate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CompactDataset_Properties_InternalId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_Properties_InternalId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InternalId != nil {
		i -= len(m.InternalId)
		copy(dAtA[i:], m.InternalId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InternalId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CompactDataset_Properties_LocalRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_Properties_LocalRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64((uint32(m.LocalRef)<<1)^uint32((m.LocalRef>>31))))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *CompactDataset_ObjectGraph) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactDataset_ObjectGraph) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_ObjectGraph) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LiteralValue != nil {
		{
			size := m.LiteralValue.Size()
			i -= size
			if _, err := m.LiteralValue.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Graphs) > 0 {
		for iNdEx := len(m.Graphs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Graphs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Lang) > 0 {
		i -= len(m.Lang)
		copy(dAtA[i:], m.Lang)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Lang)))
		i--
		dAtA[i] = 0x32
	}
	if m.Sum != nil {
		{
			size := m.Sum.Size()
			i -= size
			if _, err := m.Sum.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CompactDataset_ObjectGraph_ObjectInternalId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_ObjectGraph_ObjectInternalId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ObjectInternalId != nil {
		i -= len(m.ObjectInternalId)
		copy(dAtA[i:], m.ObjectInternalId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ObjectInternalId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CompactDataset_ObjectGraph_ObjectLocalRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_ObjectGraph_ObjectLocalRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64((uint32(m.ObjectLocalRef)<<1)^uint32((m.ObjectLocalRef>>31))))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *CompactDataset_ObjectGraph_WellKnownDatatype) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_ObjectGraph_WellKnownDatatype) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.WellKnownDatatype))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *CompactDataset_ObjectGraph_DataTypeInternalId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_ObjectGraph_DataTypeInternalId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DataTypeInternalId != nil {
		i -= len(m.DataTypeInternalId)
		copy(dAtA[i:], m.DataTypeInternalId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DataTypeInternalId)))
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CompactDataset_ObjectGraph_DataTypeLocalRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_ObjectGraph_DataTypeLocalRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64((uint32(m.DataTypeLocalRef)<<1)^uint32((m.DataTypeLocalRef>>31))))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *CompactDataset_ObjectGraph_StrValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_ObjectGraph_StrValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.StrValue)
	copy(dAtA[i:], m.StrValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.StrValue)))
	i--
	dAtA[i] = 0x42
	return len(dAtA) - i, nil
}
func (m *CompactDataset_ObjectGraph_GraphID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactDataset_ObjectGraph_GraphID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_ObjectGraph_GraphID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Graph != nil {
		{
			size := m.Graph.Size()
			i -= size
			if _, err := m.Graph.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CompactDataset_ObjectGraph_GraphID_InternalId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_ObjectGraph_GraphID_InternalId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InternalId != nil {
		i -= len(m.InternalId)
		copy(dAtA[i:], m.InternalId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InternalId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CompactDataset_ObjectGraph_GraphID_LocalRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactDataset_ObjectGraph_GraphID_LocalRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64((uint32(m.LocalRef)<<1)^uint32((m.LocalRef>>31))))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ContentHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != nil {
		n += m.Sum.Size()
	}
	return n
}

func (m *ContentHash_Raw_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Raw != nil {
		l = m.Raw.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ContentHash_Graph_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Graph != nil {
		l = m.Graph.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ContentHash_Raw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DigestAlgorithm != 0 {
		n += 1 + sovTypes(uint64(m.DigestAlgorithm))
	}
	if m.MediaType != 0 {
		n += 1 + sovTypes(uint64(m.MediaType))
	}
	return n
}

func (m *ContentHash_Graph) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DigestAlgorithm != 0 {
		n += 1 + sovTypes(uint64(m.DigestAlgorithm))
	}
	if m.CanonicalizationAlgorithm != 0 {
		n += 1 + sovTypes(uint64(m.CanonicalizationAlgorithm))
	}
	if m.MerkleTree != 0 {
		n += 1 + sovTypes(uint64(m.MerkleTree))
	}
	return n
}

func (m *Content) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != nil {
		n += m.Sum.Size()
	}
	return n
}

func (m *Content_RawData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RawData != nil {
		l = len(m.RawData)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SignerEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CompactDataset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NewIris) > 0 {
		for _, s := range m.NewIris {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CompactDataset_Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subject != nil {
		n += m.Subject.Size()
	}
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CompactDataset_Node_InternalId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternalId != nil {
		l = len(m.InternalId)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CompactDataset_Node_LocalRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sozTypes(uint64(m.LocalRef))
	return n
}
func (m *CompactDataset_Properties) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Predicate != nil {
		n += m.Predicate.Size()
	}
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CompactDataset_Properties_InternalId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternalId != nil {
		l = len(m.InternalId)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CompactDataset_Properties_LocalRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sozTypes(uint64(m.LocalRef))
	return n
}
func (m *CompactDataset_ObjectGraph) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != nil {
		n += m.Sum.Size()
	}
	l = len(m.Lang)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Graphs) > 0 {
		for _, e := range m.Graphs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LiteralValue != nil {
		n += m.LiteralValue.Size()
	}
	return n
}

func (m *CompactDataset_ObjectGraph_ObjectInternalId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectInternalId != nil {
		l = len(m.ObjectInternalId)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CompactDataset_ObjectGraph_ObjectLocalRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sozTypes(uint64(m.ObjectLocalRef))
	return n
}
func (m *CompactDataset_ObjectGraph_WellKnownDatatype) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.WellKnownDatatype))
	return n
}
func (m *CompactDataset_ObjectGraph_DataTypeInternalId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataTypeInternalId != nil {
		l = len(m.DataTypeInternalId)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CompactDataset_ObjectGraph_DataTypeLocalRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sozTypes(uint64(m.DataTypeLocalRef))
	return n
}
func (m *CompactDataset_ObjectGraph_StrValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StrValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CompactDataset_ObjectGraph_GraphID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Graph != nil {
		n += m.Graph.Size()
	}
	return n
}

func (m *CompactDataset_ObjectGraph_GraphID_InternalId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternalId != nil {
		l = len(m.InternalId)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CompactDataset_ObjectGraph_GraphID_LocalRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sozTypes(uint64(m.LocalRef))
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ContentHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContentHash_Raw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &ContentHash_Raw_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Graph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContentHash_Graph{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &ContentHash_Graph_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentHash_Raw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Raw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Raw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigestAlgorithm", wireType)
			}
			m.DigestAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigestAlgorithm |= DigestAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			m.MediaType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaType |= MediaType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentHash_Graph) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Graph: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Graph: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigestAlgorithm", wireType)
			}
			m.DigestAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigestAlgorithm |= DigestAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanonicalizationAlgorithm", wireType)
			}
			m.CanonicalizationAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CanonicalizationAlgorithm |= GraphCanonicalizationAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleTree", wireType)
			}
			m.MerkleTree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MerkleTree |= GraphMerkleTree(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Content) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Content: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Content: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Sum = &Content_RawData{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignerEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignerEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignerEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactDataset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactDataset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactDataset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &CompactDataset_Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewIris", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewIris = append(m.NewIris, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactDataset_Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Subject = &CompactDataset_Node_InternalId{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalRef", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Subject = &CompactDataset_Node_LocalRef{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, &CompactDataset_Properties{})
			if err := m.Properties[len(m.Properties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactDataset_Properties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Properties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Properties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Predicate = &CompactDataset_Properties_InternalId{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalRef", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Predicate = &CompactDataset_Properties_LocalRef{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &CompactDataset_ObjectGraph{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactDataset_ObjectGraph) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectGraph: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectGraph: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectInternalId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Sum = &CompactDataset_ObjectGraph_ObjectInternalId{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectLocalRef", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Sum = &CompactDataset_ObjectGraph_ObjectLocalRef{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WellKnownDatatype", wireType)
			}
			var v CompactDataset_WellknownDatatype
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= CompactDataset_WellknownDatatype(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sum = &CompactDataset_ObjectGraph_WellKnownDatatype{v}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTypeInternalId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Sum = &CompactDataset_ObjectGraph_DataTypeInternalId{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTypeLocalRef", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Sum = &CompactDataset_ObjectGraph_DataTypeLocalRef{v}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lang = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Graphs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Graphs = append(m.Graphs, &CompactDataset_ObjectGraph_GraphID{})
			if err := m.Graphs[len(m.Graphs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiteralValue = &CompactDataset_ObjectGraph_StrValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactDataset_ObjectGraph_GraphID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Graph = &CompactDataset_ObjectGraph_GraphID_InternalId{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalRef", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Graph = &CompactDataset_ObjectGraph_GraphID_LocalRef{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
