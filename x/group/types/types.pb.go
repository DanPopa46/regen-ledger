// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/group/v1alpha1/types.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	types1 "github.com/cosmos/cosmos-sdk/codec/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "github.com/regen-network/cosmos-proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Choice int32

const (
	Choice_UNKNOWN Choice = 0
	Choice_NO      Choice = 1
	Choice_YES     Choice = 2
	Choice_ABSTAIN Choice = 3
	Choice_VETO    Choice = 4
)

var Choice_name = map[int32]string{
	0: "UNKNOWN",
	1: "NO",
	2: "YES",
	3: "ABSTAIN",
	4: "VETO",
}

var Choice_value = map[string]int32{
	"UNKNOWN": 0,
	"NO":      1,
	"YES":     2,
	"ABSTAIN": 3,
	"VETO":    4,
}

func (x Choice) String() string {
	return proto.EnumName(Choice_name, int32(x))
}

func (Choice) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9b7906b115009838, []int{0}
}

type Proposal_Status int32

const (
	// An empty value is invalid and not allowed
	ProposalStatusInvalid Proposal_Status = 0
	// Initial status of a proposal when persisted.
	ProposalStatusSubmitted Proposal_Status = 1
	// Final status of a proposal when the final tally was executed
	ProposalStatusClosed Proposal_Status = 2
	// Final status of a proposal when the group was modified before the final tally.
	ProposalStatusAborted Proposal_Status = 3
)

var Proposal_Status_name = map[int32]string{
	0: "PROPOSAL_STATUS_INVALID",
	1: "PROPOSAL_STATUS_SUBMITTED",
	2: "PROPOSAL_STATUS_CLOSED",
	3: "PROPOSAL_STATUS_ABORTED",
}

var Proposal_Status_value = map[string]int32{
	"PROPOSAL_STATUS_INVALID":   0,
	"PROPOSAL_STATUS_SUBMITTED": 1,
	"PROPOSAL_STATUS_CLOSED":    2,
	"PROPOSAL_STATUS_ABORTED":   3,
}

func (x Proposal_Status) String() string {
	return proto.EnumName(Proposal_Status_name, int32(x))
}

func (Proposal_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9b7906b115009838, []int{5, 0}
}

type Proposal_Result int32

const (
	// An empty value is invalid and not allowed
	ProposalResultInvalid Proposal_Result = 0
	// Until a final tally has happened the status is undefined
	ProposalResultUndefined Proposal_Result = 1
	// Final result of the tally
	ProposalResultAccepted Proposal_Result = 2
	// Final result of the tally
	ProposalResultRejected Proposal_Result = 3
)

var Proposal_Result_name = map[int32]string{
	0: "PROPOSAL_RESULT_INVALID",
	1: "PROPOSAL_RESULT_UNDEFINED",
	2: "PROPOSAL_RESULT_ACCEPTED",
	3: "PROPOSAL_RESULT_REJECTED",
}

var Proposal_Result_value = map[string]int32{
	"PROPOSAL_RESULT_INVALID":   0,
	"PROPOSAL_RESULT_UNDEFINED": 1,
	"PROPOSAL_RESULT_ACCEPTED":  2,
	"PROPOSAL_RESULT_REJECTED":  3,
}

func (x Proposal_Result) String() string {
	return proto.EnumName(Proposal_Result_name, int32(x))
}

func (Proposal_Result) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9b7906b115009838, []int{5, 1}
}

type Proposal_ExecutorResult int32

const (
	// An empty value is not allowed
	ProposalExecutorResultInvalid Proposal_ExecutorResult = 0
	// We have not yet run the executor
	ProposalExecutorResultNotRun Proposal_ExecutorResult = 1
	// The executor was successful and proposed action updated state
	ProposalExecutorResultSuccess Proposal_ExecutorResult = 2
	// The executor returned an error and proposed action didn't update state
	ProposalExecutorResultFailure Proposal_ExecutorResult = 3
)

var Proposal_ExecutorResult_name = map[int32]string{
	0: "PROPOSAL_EXECUTOR_RESULT_INVALID",
	1: "PROPOSAL_EXECUTOR_RESULT_NOT_RUN",
	2: "PROPOSAL_EXECUTOR_RESULT_SUCCESS",
	3: "PROPOSAL_EXECUTOR_RESULT_FAILURE",
}

var Proposal_ExecutorResult_value = map[string]int32{
	"PROPOSAL_EXECUTOR_RESULT_INVALID": 0,
	"PROPOSAL_EXECUTOR_RESULT_NOT_RUN": 1,
	"PROPOSAL_EXECUTOR_RESULT_SUCCESS": 2,
	"PROPOSAL_EXECUTOR_RESULT_FAILURE": 3,
}

func (x Proposal_ExecutorResult) String() string {
	return proto.EnumName(Proposal_ExecutorResult_name, int32(x))
}

func (Proposal_ExecutorResult) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9b7906b115009838, []int{5, 2}
}

type Member struct {
	Address github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=address,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"address,omitempty"`
	Power   github_com_cosmos_cosmos_sdk_types.Dec        `protobuf:"bytes,2,opt,name=power,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"power"`
	Comment string                                        `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b7906b115009838, []int{0}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Member) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

// ThresholdDecisionPolicy implements the DecisionPolicy interface
type ThresholdDecisionPolicy struct {
	// threshold is a fix weight value that must be met or exceeded for a proposal to succeed.
	Threshold github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=threshold,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"threshold"`
	// timeout is the duration from submission of a proposal to the end of voting period
	// Within this times votes and exec messages can be submitted.
	Timeout types.Duration `protobuf:"bytes,2,opt,name=timeout,proto3" json:"timeout"`
}

func (m *ThresholdDecisionPolicy) Reset()         { *m = ThresholdDecisionPolicy{} }
func (m *ThresholdDecisionPolicy) String() string { return proto.CompactTextString(m) }
func (*ThresholdDecisionPolicy) ProtoMessage()    {}
func (*ThresholdDecisionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b7906b115009838, []int{1}
}
func (m *ThresholdDecisionPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThresholdDecisionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThresholdDecisionPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThresholdDecisionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdDecisionPolicy.Merge(m, src)
}
func (m *ThresholdDecisionPolicy) XXX_Size() int {
	return m.Size()
}
func (m *ThresholdDecisionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdDecisionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdDecisionPolicy proto.InternalMessageInfo

func (m *ThresholdDecisionPolicy) GetTimeout() types.Duration {
	if m != nil {
		return m.Timeout
	}
	return types.Duration{}
}

type GroupMetadata struct {
	Group   GroupID                                       `protobuf:"varint,1,opt,name=group,proto3,casttype=GroupID" json:"group,omitempty"`
	Admin   github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=admin,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"admin,omitempty"`
	Comment string                                        `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
	// version is used to track changes to a group's membership structure that
	// would break existing proposals. Whenever any members power is changed,
	// or any member is added or removed this version is incremented and will
	// cause proposals based on older versions of this group to fail
	Version     uint64                                 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	TotalWeight github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=totalWeight,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"totalWeight"`
}

func (m *GroupMetadata) Reset()         { *m = GroupMetadata{} }
func (m *GroupMetadata) String() string { return proto.CompactTextString(m) }
func (*GroupMetadata) ProtoMessage()    {}
func (*GroupMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b7906b115009838, []int{2}
}
func (m *GroupMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMetadata.Merge(m, src)
}
func (m *GroupMetadata) XXX_Size() int {
	return m.Size()
}
func (m *GroupMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMetadata proto.InternalMessageInfo

func (m *GroupMetadata) GetGroup() GroupID {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *GroupMetadata) GetAdmin() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *GroupMetadata) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *GroupMetadata) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type GroupMember struct {
	Group GroupID `protobuf:"varint,1,opt,name=group,proto3,casttype=GroupID" json:"group,omitempty"`
	// todo: @aaronc field has different name in `Member.address`. Can we unify this?
	Member github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=member,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"member,omitempty"`
	// todo: @aaronc it is `Member.power`. Can we unify this?
	Weight  github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=weight,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"weight"`
	Comment string                                 `protobuf:"bytes,4,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *GroupMember) Reset()         { *m = GroupMember{} }
func (m *GroupMember) String() string { return proto.CompactTextString(m) }
func (*GroupMember) ProtoMessage()    {}
func (*GroupMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b7906b115009838, []int{3}
}
func (m *GroupMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMember.Merge(m, src)
}
func (m *GroupMember) XXX_Size() int {
	return m.Size()
}
func (m *GroupMember) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMember.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMember proto.InternalMessageInfo

func (m *GroupMember) GetGroup() GroupID {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *GroupMember) GetMember() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Member
	}
	return nil
}

func (m *GroupMember) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

// GroupAccountMetadata specifies group account metadata
type GroupAccountMetadata struct {
	GroupAccount github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=group_account,json=groupAccount,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"group_account,omitempty"`
	Group        GroupID                                       `protobuf:"varint,2,opt,name=group,proto3,casttype=GroupID" json:"group,omitempty"`
	Admin        github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,3,opt,name=admin,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"admin,omitempty"`
	Comment      string                                        `protobuf:"bytes,4,opt,name=comment,proto3" json:"comment,omitempty"`
	// version is used to track changes to a group's GroupAccountMetadata structure that
	// would create a different result on a running proposal.
	Version        uint64      `protobuf:"varint,5,opt,name=version,proto3" json:"version,omitempty"`
	DecisionPolicy *types1.Any `protobuf:"bytes,6,opt,name=decision_policy,json=decisionPolicy,proto3" json:"decision_policy,omitempty"`
}

func (m *GroupAccountMetadata) Reset()         { *m = GroupAccountMetadata{} }
func (m *GroupAccountMetadata) String() string { return proto.CompactTextString(m) }
func (*GroupAccountMetadata) ProtoMessage()    {}
func (*GroupAccountMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b7906b115009838, []int{4}
}
func (m *GroupAccountMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupAccountMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupAccountMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupAccountMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupAccountMetadata.Merge(m, src)
}
func (m *GroupAccountMetadata) XXX_Size() int {
	return m.Size()
}
func (m *GroupAccountMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupAccountMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_GroupAccountMetadata proto.InternalMessageInfo

// Proposal defines the core field members of a group proposal.
type Proposal struct {
	GroupAccount github_com_cosmos_cosmos_sdk_types.AccAddress   `protobuf:"bytes,1,opt,name=group_account,json=groupAccount,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"group_account,omitempty"`
	Comment      string                                          `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
	Proposers    []github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,3,rep,name=proposers,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"proposers,omitempty"`
	SubmittedAt  types.Timestamp                                 `protobuf:"bytes,4,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at"`
	// GroupVersion tracks the version of the group that this proposal corresponds to. When group membership is changed
	// existing proposals for prior group versions will become invalid.
	GroupVersion uint64 `protobuf:"varint,5,opt,name=group_version,json=groupVersion,proto3" json:"group_version,omitempty"`
	// GroupAccountVersion tracks the version of the group account that this proposal corresponds to. When a decision policy is changed
	// an existing proposals for prior policy versions will become invalid.
	GroupAccountVersion uint64 `protobuf:"varint,6,opt,name=group_account_version,json=groupAccountVersion,proto3" json:"group_account_version,omitempty"`
	// Status represents the high level position in the life cycle of the proposal. Initial value is Submitted.
	Status Proposal_Status `protobuf:"varint,7,opt,name=status,proto3,enum=regen.group.v1alpha1.Proposal_Status" json:"status,omitempty"`
	// Result is the final result based on the votes and election rule. Initial value is Undefined.
	// The result is persisted so that clients can always rely on this state and not have to replicate the logic.
	Result Proposal_Result `protobuf:"varint,8,opt,name=result,proto3,enum=regen.group.v1alpha1.Proposal_Result" json:"result,omitempty"`
	// Tally contains the sums of all weighted votes for this proposal.
	VoteState Tally `protobuf:"bytes,9,opt,name=vote_state,json=voteState,proto3" json:"vote_state"`
	// Timestamp of the block where the proposal execution times out. Header times of the votes and execution messages
	// must be before this end time to be included in the election. After the timeout timestamp the proposal can not be
	// executed anymore and should be considered pending delete.
	Timeout types.Timestamp `protobuf:"bytes,10,opt,name=timeout,proto3" json:"timeout"`
	// Result is the final result based on the votes and election rule. Initial value is NotRun.
	ExecutorResult Proposal_ExecutorResult `protobuf:"varint,11,opt,name=executor_result,json=executorResult,proto3,enum=regen.group.v1alpha1.Proposal_ExecutorResult" json:"executor_result,omitempty"`
	Msgs           []*types1.Any           `protobuf:"bytes,12,rep,name=msgs,proto3" json:"msgs,omitempty"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}
func (*Proposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b7906b115009838, []int{5}
}
func (m *Proposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal.Merge(m, src)
}
func (m *Proposal) XXX_Size() int {
	return m.Size()
}
func (m *Proposal) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal proto.InternalMessageInfo

type Tally struct {
	YesCount     github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=yes_count,json=yesCount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"yes_count"`
	NoCount      github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=no_count,json=noCount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"no_count"`
	AbstainCount github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=abstain_count,json=abstainCount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"abstain_count"`
	VetoCount    github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=veto_count,json=vetoCount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"veto_count"`
}

func (m *Tally) Reset()         { *m = Tally{} }
func (m *Tally) String() string { return proto.CompactTextString(m) }
func (*Tally) ProtoMessage()    {}
func (*Tally) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b7906b115009838, []int{6}
}
func (m *Tally) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tally) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tally.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tally) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tally.Merge(m, src)
}
func (m *Tally) XXX_Size() int {
	return m.Size()
}
func (m *Tally) XXX_DiscardUnknown() {
	xxx_messageInfo_Tally.DiscardUnknown(m)
}

var xxx_messageInfo_Tally proto.InternalMessageInfo

type Vote struct {
	Proposal    ProposalID                                    `protobuf:"varint,1,opt,name=proposal,proto3,casttype=ProposalID" json:"proposal,omitempty"`
	Voter       github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=voter,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"voter,omitempty"`
	Choice      Choice                                        `protobuf:"varint,3,opt,name=choice,proto3,enum=regen.group.v1alpha1.Choice" json:"choice,omitempty"`
	Comment     string                                        `protobuf:"bytes,4,opt,name=comment,proto3" json:"comment,omitempty"`
	SubmittedAt types.Timestamp                               `protobuf:"bytes,5,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at"`
}

func (m *Vote) Reset()         { *m = Vote{} }
func (m *Vote) String() string { return proto.CompactTextString(m) }
func (*Vote) ProtoMessage()    {}
func (*Vote) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b7906b115009838, []int{7}
}
func (m *Vote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vote.Merge(m, src)
}
func (m *Vote) XXX_Size() int {
	return m.Size()
}
func (m *Vote) XXX_DiscardUnknown() {
	xxx_messageInfo_Vote.DiscardUnknown(m)
}

var xxx_messageInfo_Vote proto.InternalMessageInfo

func (m *Vote) GetProposal() ProposalID {
	if m != nil {
		return m.Proposal
	}
	return 0
}

func (m *Vote) GetVoter() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Voter
	}
	return nil
}

func (m *Vote) GetChoice() Choice {
	if m != nil {
		return m.Choice
	}
	return Choice_UNKNOWN
}

func (m *Vote) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Vote) GetSubmittedAt() types.Timestamp {
	if m != nil {
		return m.SubmittedAt
	}
	return types.Timestamp{}
}

func init() {
	proto.RegisterEnum("regen.group.v1alpha1.Choice", Choice_name, Choice_value)
	proto.RegisterEnum("regen.group.v1alpha1.Proposal_Status", Proposal_Status_name, Proposal_Status_value)
	proto.RegisterEnum("regen.group.v1alpha1.Proposal_Result", Proposal_Result_name, Proposal_Result_value)
	proto.RegisterEnum("regen.group.v1alpha1.Proposal_ExecutorResult", Proposal_ExecutorResult_name, Proposal_ExecutorResult_value)
	proto.RegisterType((*Member)(nil), "regen.group.v1alpha1.Member")
	proto.RegisterType((*ThresholdDecisionPolicy)(nil), "regen.group.v1alpha1.ThresholdDecisionPolicy")
	proto.RegisterType((*GroupMetadata)(nil), "regen.group.v1alpha1.GroupMetadata")
	proto.RegisterType((*GroupMember)(nil), "regen.group.v1alpha1.GroupMember")
	proto.RegisterType((*GroupAccountMetadata)(nil), "regen.group.v1alpha1.GroupAccountMetadata")
	proto.RegisterType((*Proposal)(nil), "regen.group.v1alpha1.Proposal")
	proto.RegisterType((*Tally)(nil), "regen.group.v1alpha1.Tally")
	proto.RegisterType((*Vote)(nil), "regen.group.v1alpha1.Vote")
}

func init() { proto.RegisterFile("regen/group/v1alpha1/types.proto", fileDescriptor_9b7906b115009838) }

var fileDescriptor_9b7906b115009838 = []byte{
	// 1321 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xbf, 0x6f, 0xdb, 0x46,
	0x1b, 0x16, 0xf5, 0xdb, 0x27, 0x47, 0x11, 0xee, 0x73, 0x12, 0x5a, 0xc9, 0x27, 0x31, 0x2a, 0x5a,
	0x18, 0x01, 0x2c, 0x21, 0x4e, 0x50, 0xb4, 0x06, 0x02, 0x94, 0x92, 0xe8, 0x40, 0x8d, 0x2d, 0xb9,
	0x24, 0xe5, 0xb4, 0x5d, 0x04, 0x8a, 0xbc, 0xc8, 0x6c, 0x28, 0x9e, 0x40, 0x1e, 0x9d, 0x68, 0xec,
	0x16, 0x78, 0xca, 0xd6, 0xc9, 0x40, 0x80, 0xfe, 0x0b, 0x6d, 0x81, 0xce, 0x5d, 0x82, 0x4e, 0x41,
	0xa7, 0xa2, 0x40, 0x8d, 0x22, 0x59, 0x0a, 0x74, 0xe9, 0xd4, 0x21, 0x53, 0xc1, 0xe3, 0xd1, 0x16,
	0x6d, 0x59, 0x71, 0xd4, 0x76, 0xb2, 0x0f, 0xef, 0xfb, 0x3c, 0xf7, 0x3e, 0xcf, 0xbd, 0xc7, 0x7b,
	0x05, 0x04, 0x07, 0x0d, 0x90, 0x5d, 0x1b, 0x38, 0xd8, 0x1b, 0xd5, 0xf6, 0x6e, 0x6a, 0xd6, 0x68,
	0x57, 0xbb, 0x59, 0x23, 0xe3, 0x11, 0x72, 0xab, 0x23, 0x07, 0x13, 0x0c, 0x97, 0x68, 0x46, 0x95,
	0x66, 0x54, 0xc3, 0x8c, 0xe2, 0xd2, 0x00, 0x0f, 0x30, 0x4d, 0xa8, 0xf9, 0xff, 0x05, 0xb9, 0xc5,
	0xd2, 0x00, 0xe3, 0x81, 0x85, 0x6a, 0x74, 0xd5, 0xf7, 0x1e, 0xd4, 0x0c, 0xcf, 0xd1, 0x88, 0x89,
	0x6d, 0x16, 0x2f, 0x9f, 0x8c, 0x13, 0x73, 0x88, 0x5c, 0xa2, 0x0d, 0x47, 0x2c, 0x61, 0x59, 0xc7,
	0xee, 0x10, 0xbb, 0xbd, 0x80, 0x39, 0x58, 0x84, 0xa1, 0x93, 0x58, 0xcd, 0x1e, 0x07, 0xa1, 0xca,
	0xb7, 0x1c, 0x48, 0x6f, 0xa1, 0x61, 0x1f, 0x39, 0xf0, 0x1e, 0xc8, 0x68, 0x86, 0xe1, 0x20, 0xd7,
	0xe5, 0x39, 0x81, 0x5b, 0x59, 0xac, 0xdf, 0x7c, 0x7d, 0x58, 0x5e, 0x1d, 0x98, 0x64, 0xd7, 0xeb,
	0x57, 0x75, 0x3c, 0x64, 0x9c, 0xec, 0xcf, 0xaa, 0x6b, 0x3c, 0x64, 0x62, 0x45, 0x5d, 0x17, 0x03,
	0xa0, 0x1c, 0x32, 0xc0, 0x26, 0x48, 0x8d, 0xf0, 0x23, 0xe4, 0xf0, 0x71, 0x81, 0x5b, 0x59, 0xa8,
	0x57, 0x9f, 0x1f, 0x96, 0x63, 0xbf, 0x1c, 0x96, 0xdf, 0x3b, 0x07, 0x5d, 0x13, 0xe9, 0x72, 0x00,
	0x86, 0x3c, 0xc8, 0xe8, 0x78, 0x38, 0x44, 0x36, 0xe1, 0x13, 0x3e, 0x8f, 0x1c, 0x2e, 0x2b, 0xdf,
	0x71, 0xe0, 0x8a, 0xba, 0xeb, 0x20, 0x77, 0x17, 0x5b, 0x46, 0x13, 0xe9, 0xa6, 0x6b, 0x62, 0x7b,
	0x1b, 0x5b, 0xa6, 0x3e, 0x86, 0x9b, 0x60, 0x81, 0x84, 0x21, 0x2a, 0xe5, 0xed, 0xf7, 0x3f, 0x26,
	0x80, 0x1f, 0x82, 0x8c, 0x6f, 0x35, 0xf6, 0x08, 0xd5, 0x92, 0x5b, 0x5b, 0xae, 0x06, 0x76, 0x56,
	0x43, 0x3b, 0xab, 0x4d, 0x76, 0x54, 0xf5, 0xa4, 0xbf, 0x8d, 0x1c, 0xe6, 0xaf, 0xc3, 0x9f, 0xbe,
	0x59, 0xcd, 0x47, 0x8b, 0xab, 0x7c, 0x19, 0x07, 0x17, 0xee, 0xfa, 0x0d, 0xb1, 0x85, 0x88, 0x66,
	0x68, 0x44, 0x83, 0xd7, 0x41, 0x8a, 0x76, 0x08, 0x2d, 0x35, 0x59, 0xcf, 0xbd, 0x3e, 0x2c, 0x67,
	0x68, 0x46, 0xab, 0x29, 0x07, 0x11, 0x78, 0x17, 0xa4, 0x34, 0x63, 0x68, 0xda, 0xb4, 0x82, 0xb9,
	0x0e, 0x26, 0xc0, 0x9f, 0x6d, 0xa8, 0x1f, 0xd9, 0x43, 0x8e, 0x5f, 0x28, 0x9f, 0xf4, 0xeb, 0x90,
	0xc3, 0x25, 0xdc, 0x06, 0x39, 0x82, 0x89, 0x66, 0xdd, 0x47, 0xe6, 0x60, 0x97, 0xf0, 0xa9, 0xb9,
	0x0c, 0x9d, 0xa4, 0xa8, 0xfc, 0xca, 0x81, 0x1c, 0xf3, 0x80, 0x76, 0xde, 0x39, 0x1c, 0x68, 0x81,
	0xf4, 0x90, 0x26, 0xcf, 0x6f, 0x01, 0x23, 0x80, 0x1b, 0x20, 0xfd, 0x28, 0x90, 0x92, 0x98, 0x4b,
	0x0a, 0x43, 0x4f, 0x7a, 0x99, 0x8c, 0x36, 0xe7, 0x1f, 0x71, 0xb0, 0x44, 0xeb, 0x17, 0x75, 0x1d,
	0x7b, 0x36, 0x39, 0x3a, 0xea, 0x1d, 0x70, 0x81, 0xca, 0xe9, 0x69, 0x41, 0x60, 0xfe, 0x8b, 0xb6,
	0x38, 0x98, 0xe0, 0x3f, 0x36, 0x30, 0xfe, 0xe6, 0x16, 0x4a, 0xfc, 0x7b, 0x2d, 0x94, 0x3c, 0xb3,
	0x85, 0x52, 0xd1, 0x16, 0xfa, 0x04, 0x5c, 0x34, 0xd8, 0x35, 0xe8, 0x8d, 0xe8, 0x3d, 0xe0, 0xd3,
	0xf4, 0x2e, 0x2d, 0x9d, 0xba, 0x4b, 0xa2, 0x3d, 0xae, 0xc3, 0x1f, 0x4f, 0xdd, 0x1b, 0x39, 0x6f,
	0x44, 0xd6, 0xeb, 0xd9, 0x27, 0xcf, 0xca, 0xb1, 0xdf, 0x9f, 0x95, 0xb9, 0xca, 0x57, 0x8b, 0x20,
	0xbb, 0xed, 0xe0, 0x11, 0x76, 0x35, 0xeb, 0x3f, 0x73, 0x78, 0x42, 0x75, 0x3c, 0xaa, 0xba, 0x03,
	0x16, 0x46, 0x74, 0x77, 0xe4, 0xb8, 0x7c, 0x42, 0x48, 0xcc, 0xb7, 0xdb, 0x31, 0x07, 0x6c, 0x80,
	0x45, 0xd7, 0xeb, 0x0f, 0x4d, 0x42, 0x90, 0xd1, 0xd3, 0x02, 0x97, 0x73, 0x6b, 0xc5, 0x53, 0x4e,
	0xa9, 0xe1, 0x03, 0xc0, 0x3e, 0x3b, 0xb9, 0x23, 0x94, 0x48, 0xe0, 0x3b, 0xa1, 0x0f, 0xd1, 0x13,
	0x09, 0x44, 0xed, 0xb0, 0x63, 0x59, 0x03, 0x97, 0x22, 0x66, 0x1d, 0x25, 0xa7, 0x69, 0xf2, 0xff,
	0x26, 0x1d, 0x08, 0x31, 0x77, 0x40, 0xda, 0x25, 0x1a, 0xf1, 0x5c, 0x3e, 0x23, 0x70, 0x2b, 0xf9,
	0xb5, 0x77, 0xab, 0xd3, 0x1e, 0xb9, 0x6a, 0x78, 0x20, 0x55, 0x85, 0x26, 0xcb, 0x0c, 0xe4, 0xc3,
	0x1d, 0xe4, 0x7a, 0x16, 0xe1, 0xb3, 0xe7, 0x82, 0xcb, 0x34, 0x59, 0x66, 0x20, 0xf8, 0x11, 0x00,
	0x7b, 0x98, 0xa0, 0x9e, 0xcf, 0x86, 0xf8, 0x05, 0xea, 0xcc, 0xd5, 0xe9, 0x14, 0xaa, 0x66, 0x59,
	0x63, 0x66, 0xcd, 0x82, 0x0f, 0xf2, 0x2b, 0x41, 0x70, 0xfd, 0xf8, 0x73, 0x0e, 0xce, 0x69, 0x6c,
	0x08, 0x80, 0x3b, 0xe0, 0x22, 0x7a, 0x8c, 0x74, 0x8f, 0x60, 0xa7, 0xc7, 0x54, 0xe4, 0xa8, 0x8a,
	0xd5, 0x37, 0xa8, 0x90, 0x18, 0x8a, 0xa9, 0xc9, 0xa3, 0xc8, 0x1a, 0xae, 0x80, 0xe4, 0xd0, 0x1d,
	0xb8, 0xfc, 0xa2, 0x90, 0x38, 0xeb, 0x4e, 0xc8, 0x34, 0xa3, 0xf2, 0x27, 0x07, 0xd2, 0x81, 0xa3,
	0xf0, 0x7d, 0x70, 0x65, 0x5b, 0xee, 0x6c, 0x77, 0x14, 0x71, 0xb3, 0xa7, 0xa8, 0xa2, 0xda, 0x55,
	0x7a, 0xad, 0xf6, 0x8e, 0xb8, 0xd9, 0x6a, 0x16, 0x62, 0xc5, 0xe5, 0xfd, 0x03, 0xe1, 0x52, 0xb8,
	0x7d, 0x00, 0x68, 0xd9, 0x7b, 0x9a, 0x65, 0x1a, 0x70, 0x1d, 0x2c, 0x9f, 0xc4, 0x29, 0xdd, 0xfa,
	0x56, 0x4b, 0x55, 0xa5, 0x66, 0x81, 0x2b, 0x5e, 0xdd, 0x3f, 0x10, 0xae, 0x44, 0x91, 0x4a, 0xd8,
	0x57, 0xf0, 0x36, 0xb8, 0x7c, 0x12, 0xdb, 0xd8, 0xec, 0x28, 0x52, 0xb3, 0x10, 0x2f, 0xf2, 0xfb,
	0x07, 0xc2, 0x52, 0x14, 0xd8, 0xb0, 0xb0, 0x8b, 0x8c, 0x69, 0x95, 0x8a, 0xf5, 0x8e, 0xec, 0xef,
	0x97, 0x98, 0x56, 0xa9, 0xd8, 0xc7, 0x0e, 0x41, 0x46, 0x31, 0xf9, 0xe4, 0xeb, 0x52, 0xac, 0xf2,
	0x17, 0x07, 0xd2, 0xcc, 0xa7, 0x49, 0x22, 0x59, 0x52, 0xba, 0x9b, 0xea, 0x59, 0x92, 0x03, 0xc0,
	0x34, 0xc9, 0x0c, 0xd7, 0x6d, 0x37, 0xa5, 0x8d, 0x56, 0xfb, 0xb4, 0xe4, 0x00, 0xd9, 0xb5, 0x0d,
	0xf4, 0xc0, 0xb4, 0x91, 0x01, 0x3f, 0x00, 0xfc, 0x49, 0xac, 0xd8, 0x68, 0x48, 0xdb, 0x2a, 0x15,
	0x5d, 0xdc, 0x3f, 0x10, 0x2e, 0x47, 0xa1, 0xa2, 0xae, 0xa3, 0x11, 0x99, 0x8e, 0x94, 0xa5, 0x8f,
	0xa5, 0x46, 0xa0, 0x7b, 0x0a, 0x52, 0x46, 0x5f, 0x20, 0xfd, 0x58, 0xf8, 0xf7, 0x71, 0x90, 0x8f,
	0x36, 0x0e, 0xbc, 0x0b, 0x84, 0x23, 0x4a, 0xe9, 0x53, 0xa9, 0xd1, 0x55, 0x3b, 0xf2, 0x69, 0x27,
	0xae, 0xef, 0x1f, 0x08, 0xff, 0x0f, 0xa9, 0xa3, 0x0c, 0xa1, 0x23, 0x1b, 0x33, 0x88, 0xda, 0x1d,
	0xb5, 0x27, 0x77, 0xdb, 0x05, 0xae, 0x28, 0xec, 0x1f, 0x08, 0xd7, 0xa6, 0x13, 0xb5, 0x31, 0x91,
	0x3d, 0x7b, 0x66, 0x41, 0x4a, 0xb7, 0xd1, 0x90, 0x14, 0xa5, 0x10, 0x9f, 0x55, 0x90, 0xe2, 0xe9,
	0xba, 0x3f, 0x2f, 0xce, 0x22, 0xda, 0x10, 0x5b, 0x9b, 0x5d, 0x59, 0x2a, 0x24, 0x66, 0x11, 0x6d,
	0x68, 0xa6, 0xe5, 0x39, 0x28, 0xf0, 0x6e, 0x3d, 0xe9, 0xbf, 0x0e, 0x95, 0x1f, 0xe2, 0x20, 0x45,
	0x3f, 0x03, 0xf0, 0x1e, 0x58, 0x18, 0x23, 0xb7, 0x77, 0xfc, 0x24, 0xbc, 0xfd, 0xb3, 0x9f, 0x1d,
	0x23, 0xb7, 0x41, 0xdf, 0x82, 0x16, 0xc8, 0xda, 0x98, 0x71, 0xcd, 0x37, 0xde, 0x66, 0x6c, 0x1c,
	0x50, 0x29, 0xe0, 0x82, 0xd6, 0x77, 0x89, 0x66, 0xda, 0x8c, 0x6f, 0xbe, 0x91, 0x64, 0x91, 0x91,
	0x04, 0xa4, 0x5b, 0x00, 0xec, 0x21, 0x12, 0x56, 0x98, 0x9c, 0x6f, 0x00, 0xf6, 0x19, 0x28, 0x5d,
	0xe5, 0x69, 0x1c, 0x24, 0x77, 0x30, 0x41, 0xf0, 0x06, 0xc8, 0x8e, 0x98, 0xf7, 0x6c, 0x52, 0xcb,
	0xbf, 0x3e, 0x2c, 0x83, 0xf0, 0x3c, 0x5a, 0x4d, 0xf9, 0x28, 0xee, 0x8f, 0x1b, 0xfe, 0x37, 0xf7,
	0x1f, 0x8c, 0x6b, 0x01, 0x1e, 0xde, 0x06, 0x69, 0x7d, 0x17, 0x9b, 0x3a, 0xa2, 0xd6, 0xe4, 0xd7,
	0xae, 0x4d, 0xff, 0xd4, 0x36, 0x68, 0x8e, 0xcc, 0x72, 0x67, 0x0c, 0x29, 0x27, 0x5f, 0xd7, 0xd4,
	0x1c, 0xaf, 0xeb, 0x8d, 0x3b, 0x20, 0x1d, 0x6c, 0x08, 0x73, 0x20, 0xd3, 0x6d, 0xdf, 0x6b, 0x77,
	0xee, 0xb7, 0x0b, 0x31, 0x98, 0x06, 0xf1, 0x76, 0xa7, 0xc0, 0xc1, 0x0c, 0x48, 0x7c, 0x26, 0x29,
	0x85, 0xb8, 0x1f, 0x15, 0xeb, 0x8a, 0x2a, 0xb6, 0xda, 0x85, 0x04, 0xcc, 0x82, 0xe4, 0x8e, 0xa4,
	0x76, 0x0a, 0xc9, 0xfa, 0xd6, 0xf3, 0x97, 0x25, 0xee, 0xc5, 0xcb, 0x12, 0xf7, 0xdb, 0xcb, 0x12,
	0xf7, 0xf4, 0x55, 0x29, 0xf6, 0xe2, 0x55, 0x29, 0xf6, 0xf3, 0xab, 0x52, 0xec, 0xf3, 0x5b, 0x13,
	0x1e, 0x51, 0x9d, 0xab, 0x36, 0x22, 0x8f, 0xb0, 0xf3, 0x90, 0xad, 0x2c, 0x64, 0x0c, 0x90, 0x53,
	0x7b, 0xcc, 0x7e, 0x75, 0x52, 0xd3, 0xfa, 0x69, 0x5a, 0xf4, 0xad, 0xbf, 0x03, 0x00, 0x00, 0xff,
	0xff, 0x3d, 0x2a, 0x19, 0xbb, 0x91, 0x0e, 0x00, 0x00,
}

func (this *GroupAccountMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GroupAccountMetadata)
	if !ok {
		that2, ok := that.(GroupAccountMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.GroupAccount, that1.GroupAccount) {
		return false
	}
	if this.Group != that1.Group {
		return false
	}
	if !bytes.Equal(this.Admin, that1.Admin) {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.DecisionPolicy.Equal(that1.DecisionPolicy) {
		return false
	}
	return true
}
func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Power.Size()
		i -= size
		if _, err := m.Power.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ThresholdDecisionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThresholdDecisionPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdDecisionPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Timeout.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Threshold.Size()
		i -= size
		if _, err := m.Threshold.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GroupMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalWeight.Size()
		i -= size
		if _, err := m.TotalWeight.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Version != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if m.Group != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GroupMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.Weight.Size()
		i -= size
		if _, err := m.Weight.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Member) > 0 {
		i -= len(m.Member)
		copy(dAtA[i:], m.Member)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Member)))
		i--
		dAtA[i] = 0x12
	}
	if m.Group != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GroupAccountMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupAccountMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupAccountMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DecisionPolicy != nil {
		{
			size, err := m.DecisionPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Version != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Group != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GroupAccount) > 0 {
		i -= len(m.GroupAccount)
		copy(dAtA[i:], m.GroupAccount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupAccount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Proposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msgs) > 0 {
		for iNdEx := len(m.Msgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Msgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.ExecutorResult != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExecutorResult))
		i--
		dAtA[i] = 0x58
	}
	{
		size, err := m.Timeout.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.VoteState.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.Result != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x40
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.GroupAccountVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GroupAccountVersion))
		i--
		dAtA[i] = 0x30
	}
	if m.GroupVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GroupVersion))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.SubmittedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Proposers) > 0 {
		for iNdEx := len(m.Proposers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Proposers[iNdEx])
			copy(dAtA[i:], m.Proposers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Proposers[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.GroupAccount) > 0 {
		i -= len(m.GroupAccount)
		copy(dAtA[i:], m.GroupAccount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupAccount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tally) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tally) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tally) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.VetoCount.Size()
		i -= size
		if _, err := m.VetoCount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.AbstainCount.Size()
		i -= size
		if _, err := m.AbstainCount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.NoCount.Size()
		i -= size
		if _, err := m.NoCount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.YesCount.Size()
		i -= size
		if _, err := m.YesCount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Vote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.SubmittedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x22
	}
	if m.Choice != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Choice))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0x12
	}
	if m.Proposal != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Proposal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Power.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ThresholdDecisionPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Threshold.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Timeout.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *GroupMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != 0 {
		n += 1 + sovTypes(uint64(m.Group))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	l = m.TotalWeight.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *GroupMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != 0 {
		n += 1 + sovTypes(uint64(m.Group))
	}
	l = len(m.Member)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Weight.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GroupAccountMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupAccount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovTypes(uint64(m.Group))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	if m.DecisionPolicy != nil {
		l = m.DecisionPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupAccount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Proposers) > 0 {
		for _, b := range m.Proposers {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = m.SubmittedAt.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.GroupVersion != 0 {
		n += 1 + sovTypes(uint64(m.GroupVersion))
	}
	if m.GroupAccountVersion != 0 {
		n += 1 + sovTypes(uint64(m.GroupAccountVersion))
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	if m.Result != 0 {
		n += 1 + sovTypes(uint64(m.Result))
	}
	l = m.VoteState.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Timeout.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.ExecutorResult != 0 {
		n += 1 + sovTypes(uint64(m.ExecutorResult))
	}
	if len(m.Msgs) > 0 {
		for _, e := range m.Msgs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Tally) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.YesCount.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.NoCount.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.AbstainCount.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.VetoCount.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != 0 {
		n += 1 + sovTypes(uint64(m.Proposal))
	}
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Choice != 0 {
		n += 1 + sovTypes(uint64(m.Choice))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.SubmittedAt.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Power.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThresholdDecisionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThresholdDecisionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThresholdDecisionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalWeight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalWeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Member = append(m.Member[:0], dAtA[iNdEx:postIndex]...)
			if m.Member == nil {
				m.Member = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Weight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupAccountMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupAccountMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupAccountMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAccount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupAccount = append(m.GroupAccount[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupAccount == nil {
				m.GroupAccount = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DecisionPolicy == nil {
				m.DecisionPolicy = &types1.Any{}
			}
			if err := m.DecisionPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAccount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupAccount = append(m.GroupAccount[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupAccount == nil {
				m.GroupAccount = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposers = append(m.Proposers, make([]byte, postIndex-iNdEx))
			copy(m.Proposers[len(m.Proposers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SubmittedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupVersion", wireType)
			}
			m.GroupVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAccountVersion", wireType)
			}
			m.GroupAccountVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupAccountVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Proposal_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= Proposal_Result(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VoteState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorResult", wireType)
			}
			m.ExecutorResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutorResult |= Proposal_ExecutorResult(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msgs = append(m.Msgs, &types1.Any{})
			if err := m.Msgs[len(m.Msgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tally) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tally: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tally: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YesCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.YesCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NoCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbstainCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AbstainCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VetoCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VetoCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			m.Proposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposal |= ProposalID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = append(m.Voter[:0], dAtA[iNdEx:postIndex]...)
			if m.Voter == nil {
				m.Voter = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Choice", wireType)
			}
			m.Choice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Choice |= Choice(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SubmittedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
